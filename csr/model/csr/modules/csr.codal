/**
 * Codasip s.r.o.
 *
 * CONFIDENTIAL
 *
 * Copyright 2022 Codasip s.r.o.
 *
 * All Rights Reserved.
 *
 * NOTICE: All information contained in this file, is and shall remain the property of
 * Codasip s.r.o. and its suppliers, if any.
 *
 * The intellectual and technical concepts contained herein are confidential and proprietary to
 * Codasip s.r.o. and are protected by trade secret and copyright law.  In addition, elements of the
 * technical concepts may be patent pending.
 *
 * This file is part of the Codasip Studio product. No part of the Studio product, including this
 * file, may be use, copied, modified, or distributed except in accordance with the terms contained
 * in Codasip license agreement under which you obtained this file.
 */

//pipeline pipe { stage EX1; stage EX2; stage EX3; };
#include "shared_defines.hcodal"
#include "csr_define.hcodal"
#include "cheri_defines.hcodal"
#include "cheri_csr_defines.hcodal"

//OPTION_HAS_CHERI
//OPTION_HAS_L2CACHE
//OPTION_EXTENSION_V
//OPTION_XLEN==64 for RV64
//OPTION_XLEN==32 for RV32

//function names: set_xxx() - to drive csr input; get_yyy() - to drive csr output

#define SXLEN           XLEN
#define MXLEN           XLEN
#define DXLEN           XLEN
#define VLEN            OPTION_VLEN
#define TRIGGERS        4
#define CSR_SYS_OP      0b1110011
#define PMP_EXISTS
#define PMP_ENABLE      PMP_EXISTS

enum csr_op : uint4
{
    CSR_CSRRW  = 0b0001,
    CSR_CSRRS  = 0b0010,
    CSR_CSRRC  = 0b0011,
    CSR_CSRRWI = 0b0100,
    CSR_CSRRSI = 0b0101,
    CSR_CSRRCI = 0b0111,
    CSR_ECALL  = 0b1000,
    CSR_EBREAK = 0b1001,
    CSR_SRET   = 0b1010,
    CSR_MRET   = 0b1011,
    CSR_DRET   = 0b1100,
    CSR_WFI    = 0b1111,
};

enum csr_mode : uint2
{
    OP_MODE_U  = 0b000,
    OP_MODE_S  = 0b001,
    OP_MODE_M  = 0b011,
};

module csr_t
{
    csr_data_conv_t m_data_conv;

// ********************************************************************************************
//  Register declaration
// ********************************************************************************************
//-------- AUTOGEN BEGIN (reg_declare) --------
    register struct fcsr_t                          r_fcsr              { default = {0,0}; };                                                   //0x003
    register struct stvec_t                         r_stvec             { reset = false; };                                                     //0x105
    register struct scounteren_t                    r_scounteren        { default = {0,0,0,0}; };                                               //0x106
    register uint_<{SXLEN}>                         r_senvcfg           { default = 0; };                                                       //0x10a
    register uint_<{SXLEN}>                         r_sscratch          { default = 0; };                                                       //0x140
    register struct sepc_t                          r_sepc              { default = {0}; };                                                     //0x141
    register struct scause_t                        r_scause            { reset = false; };                                                     //0x142
    register uint_<{SXLEN}>                         r_stval             { reset = false; };                                                     //0x143
    register struct satp_t                          r_satp              { default = {0,0,0}; };                                                 //0x180
    register struct misa_t                          r_misa              { default = {1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,1,0,0,2}; }; //0x301
    register struct medeleg_t                       r_medeleg           { default = {0,0,0,0,0,0,0,0,0,0,0,0,0,0}; };                           //0x302
    register struct mideleg_t                       r_mideleg           { default = {0,0,0,0,0,0}; };                                           //0x303
    register struct mie_t                           r_mie               { default = {0,0,0,0,0,0}; };                                           //0x304
    register struct mtvec_t                         r_mtvec             { reset = false; };                                                     //0x305
    register struct mcounteren_t                    r_mcounteren        { default = {0,0,0,0}; };                                               //0x306
    register uint_<{MXLEN}>                         r_menvcfg           { default = 0; };                                                       //0x30a
    register struct mcountinhibit_t                 r_mcountinhibit     { default = {0,0,0}; };                                                 //0x320
    register struct mhpmevent3_t                    r_mhpmevent3        { reset = false; };                                                     //0x323
    register struct mhpmevent4_t                    r_mhpmevent4        { reset = false; };                                                     //0x324
    register struct mhpmevent5_t                    r_mhpmevent5        { reset = false; };                                                     //0x325
    register struct mhpmevent6_t                    r_mhpmevent6        { reset = false; };                                                     //0x326
    register uint_<{MXLEN}>                         r_mscratch          { default = 0; };                                                       //0x340
    register struct mepc_t                          r_mepc              { default = {0}; };                                                     //0x341
    register struct mcause_t                        r_mcause            { reset = false; };                                                     //0x342
    register uint_<{MXLEN}>                         r_mtval             { reset = false; };                                                     //0x343
    register struct mip_t                           r_mip               { default = {0,0,0,0,0,0}; };                                           //0x344
    register uint_<{MXLEN}>                         r_pmpcfg0           { default = 0; };                                                       //0x3a0
    register uint_<{MXLEN}>                         r_pmpcfg2           { default = 0; };                                                       //0x3a2
    register uint_<{MXLEN}>                         r_pmpcfg4           { default = 0; };                                                       //0x3a4
    register uint_<{MXLEN}>                         r_pmpcfg6           { default = 0; };                                                       //0x3a6
    register uint_<{MXLEN}>                         r_pmpaddr0          { reset = false; };                                                     //0x3b0
    register uint_<{MXLEN}>                         r_pmpaddr1          { reset = false; };                                                     //0x3b1
    register uint_<{MXLEN}>                         r_pmpaddr2          { reset = false; };                                                     //0x3b2
    register uint_<{MXLEN}>                         r_pmpaddr3          { reset = false; };                                                     //0x3b3
    register uint_<{MXLEN}>                         r_pmpaddr4          { reset = false; };                                                     //0x3b4
    register uint_<{MXLEN}>                         r_pmpaddr5          { reset = false; };                                                     //0x3b5
    register uint_<{MXLEN}>                         r_pmpaddr6          { reset = false; };                                                     //0x3b6
    register uint_<{MXLEN}>                         r_pmpaddr7          { reset = false; };                                                     //0x3b7
    register uint_<{MXLEN}>                         r_pmpaddr8          { reset = false; };                                                     //0x3b8
    register uint_<{MXLEN}>                         r_pmpaddr9          { reset = false; };                                                     //0x3b9
    register uint_<{MXLEN}>                         r_pmpaddr10         { reset = false; };                                                     //0x3ba
    register uint_<{MXLEN}>                         r_pmpaddr11         { reset = false; };                                                     //0x3bb
    register uint_<{MXLEN}>                         r_pmpaddr12         { reset = false; };                                                     //0x3bc
    register uint_<{MXLEN}>                         r_pmpaddr13         { reset = false; };                                                     //0x3bd
    register uint_<{MXLEN}>                         r_pmpaddr14         { reset = false; };                                                     //0x3be
    register uint_<{MXLEN}>                         r_pmpaddr15         { reset = false; };                                                     //0x3bf
    register struct sbpredctrl_t                    r_sbpredctrl        { default = {0}; };                                                     //0x5e8
    register struct tselect_t                       r_tselect           { reset = false; };                                                     //0x7a0
    register uint_<{XLEN}>                          r_tdata1[TRIGGERS]  { default = 0; };                                                       //0x7a1
    register uint_<{XLEN}>                          r_tdata2[TRIGGERS]  { reset = false; };                                                     //0x7a2
    register uint_<{XLEN}>                          r_tinfo             { default = 0x40; };                                                    //0x7a4
    register struct dcsr_t                          r_dcsr              { default = {3,0,0,0,0,0,0,0,0,0,0,0,0,0,4}; };                         //0x7b0
    register struct dpc_t                           r_dpc               { default = {0}; };                                                     //0x7b1
    register uint_<{DXLEN}>                         r_dscratch0         { reset = false; };                                                     //0x7b2
    register uint_<{DXLEN}>                         r_dscratch1         { reset = false; };                                                     //0x7b3
    register struct mcfgctrl_t                      r_mcfgctrl          { default = {0,1,0,0,0,0,0,0,0}; };                                     //0x7e0
    register struct mcachestatus_t                  r_mcachestatus      { default = {0,0,0,0,0,0}; };                                           //0x7e4
    register struct mdcachectrl_t                   r_mdcachectrl       { default = {0}; };                                                     //0x7e5
    register struct micachectrl_t                   r_micachectrl       { default = {0}; };                                                     //0x7e6
    register uint_<{MXLEN}>                         r_mcycle            { default = 0; };                                                       //0xb00
    register uint_<{MXLEN}>                         r_minstret          { default = 0; };                                                       //0xb02
    register uint_<{MXLEN}>                         r_mhpmcounter3      { default = 0; };                                                       //0xb03
    register uint_<{MXLEN}>                         r_mhpmcounter4      { default = 0; };                                                       //0xb04
    register uint_<{MXLEN}>                         r_mhpmcounter5      { default = 0; };                                                       //0xb05
    register uint_<{MXLEN}>                         r_mhpmcounter6      { default = 0; };                                                       //0xb06
    register uint32                                 r_mvendorid         { default = 0x503; };                                                   //0xf11
    register struct marchid_t                       r_marchid           { default = {5, //obilix
                                                                  #if (OPTION_XLEN == 64)
                                                                      #ifdef OPTION_HAS_VM
                                                                                     5, //arch: rv64/VM (A71)
                                                                      #else
                                                                                     4, //arch: rv64/noVM (H71)
                                                                      #endif
                                                                  #else
                                                                                     0, //arch: rv32/noVM (L71)
                                                                  #endif
                                                                                     0, //fusa
                                                                  #ifdef OPTION_HAS_CHERI
                                                                                     1, //cheri on
                                                                  #else
                                                                                     0, //cheri off
                                                                  #endif
                                                                  #ifdef OPTION_EXTENSION_V
                                                                      #if (OPTION_VLEN == 128)
                                                                                     1, //vector128
                                                                      #else
                                                                                     2, //vector256
                                                                      #endif
                                                                  #else
                                                                                     0, //no vector
                                                                  #endif
                                                                                     1}; }; //0xf12
    register uint_<{MXLEN}>                         r_mimpid            { default = 0x000; };                                                   //0xf13
    register uint_<{MXLEN}>                         r_mhartid           { reset = false; };                                                     //0xf14
    register uint_<{MXLEN}>                         r_mconfigptr        { reset = false; };                                                     //0xf15
#if (OPTION_XLEN == 64)
    register uint_<{clog2(VLEN)}>                   r_vstart            { default = 0; };                                                       //0x008
    register struct vcsr_t                          r_vcsr              { default = {0,0}; };                                                   //0x00f
    register struct mstatus_t                       r_mstatus           { default = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0}; };             //0x300
    register struct ml2cachectrl_t                  r_ml2cachectrl      { default = {0}; };                                                     //0x7e7
    register uint_<{XLEN}>                          r_vl                { default = 128; };                                                     //0xc20
    register struct vtype_t                         r_vtype             { default = {0,0,0,0,1}; };                                             //0xc21
    register uint_<{XLEN}>                          r_vlenb             { default = 16; };                                                      //0xc22
#endif //(OPTION_XLEN == 64)
#if (OPTION_XLEN == 32)
    register struct mstatus_t                       r_mstatus           { default = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; };                     //0x300
    register struct mstatush_t                      r_mstatush          { default = {0,0}; };                                                   //0x310
    register struct menvcfgh_t                      r_menvcfgh          { default = {0,0}; };                                                   //0x31a
    register uint32                                 r_pmpcfg1           { default = 0; };                                                       //0x3a1
    register uint32                                 r_pmpcfg3           { default = 0; };                                                       //0x3a3
    register uint32                                 r_pmpcfg5           { default = 0; };                                                       //0x3a5
    register uint32                                 r_pmpcfg7           { default = 0; };                                                       //0x3a7
    register uint32                                 r_mcycleh           { default = 0; };                                                       //0xb80
    register uint32                                 r_minstreth         { default = 0; };                                                       //0xb82
    register uint32                                 r_mhpmcounter3h     { default = 0; };                                                       //0xb83
    register uint32                                 r_mhpmcounter4h     { default = 0; };                                                       //0xb84
    register uint32                                 r_mhpmcounter5h     { default = 0; };                                                       //0xb85
    register uint32                                 r_mhpmcounter6h     { default = 0; };                                                       //0xb86
#endif //(OPTION_XLEN == 32)
//-------- AUTOGEN END (reg_declare) --------

    //----------------------------------------
    // Internal registers
    //----------------------------------------
    //EX1-EX2
    register uint1              r_instr_csrrw_ex2;
    register uint1              r_instr_csrwo_ex2;
    register uint1              r_instr_csrrs_ex2;
    register uint1              r_instr_csrrc_ex2;
    register uint1              r_instr_csrro_ex2;
    register uint12             r_instr_addr_updt_ex2;   //csr field of the opcode updated for shadow register
    register csr_addr_t         r_instr_opcode_csr_ex2;
    register uint5              r_instr_opcode_rs1_ex2;    
    register uint3              r_instr_opcode_func3_ex2;
    register uint3              r_instr_opcode_rd_ex2;
    register xlen_t             r_instr_rs1_val_ex2;
    register uint1              r_instr_ebreak_ex2;
    register uint1              r_instr_ecall_ex2;
    register uint1              r_instr_dret_ex2;
    register uint1              r_instr_mret_ex2;
    register uint1              r_instr_sret_ex2;
    register uint1              r_instr_wfi_ex2;

    register uint1              r_shdw_rd_time_ex2;
#if (OPTION_XLEN == 32)
    register uint1              r_shdw_rd_timeh_ex2;
#endif
    register uint1              r_shdw_dbg_reg_ex2; //read/write dm.ddata0
    register uint1              r_shdw_read_err_ex2;  //read diabled register
    register uint1              r_shdw_write_err_ex2; //write to RO register
    register uint1              r_dbg_only_err_ex2; //read/write debug-only register outside debug-mode

    uint1                       r_trigger_match_ex2;
    uint1                       r_trigger_type_ex2;
    uint1                       r_trigger_is_i1_ex2;
    uint3                       r_trigger_action_ex2;
    uint_<{clog2(TRIGGERS)}>    r_trigger_idx_ex2;

    //EX2-EX3
    register uint1              r_read_ex3;
    register xlen_t             r_rdata_ex3;
    register uint1              r_instr_csrrw_ex3;
    register uint1              r_instr_csrwo_ex3;
    register uint1              r_instr_csrrs_ex3;
    register uint1              r_instr_csrrc_ex3;
    register uint1              r_instr_csrro_ex3;
    register csr_addr_t         r_instr_addr_orig_ex3;
    register uint12             r_instr_addr_updt_ex3;
    register xlen_t             r_instr_rs1_val_ex3;
    register uint1              r_csr_excep_ind_ex3;
    register uint32             r_csr_excep_arg_ex3;
    register uint1              r_shdw_dbg_reg_ex3; //read/write dm.ddata0

    uint_<{clog2(TRIGGERS)}>    r_trigger_idx_ex3;

    //EX3-WB
    register uint1              r_write_wb;
    register uint1              r_dbg_write_wb; //write valid to dm.ddata0
    register xlen_t             r_dbg_wdata_wb; //write data to dm.ddata0


// ********************************************************************************************
//  Wire Declaration
// ********************************************************************************************

    //struct srdata_t             s_rdata;       //all physical registers
    struct swr_t                s_swr;          //all physical registers supporting SW writes (not RO, not ROZ)
    xlen_t                      s_swdata;       //all physical registers supporting SW writes (not RO, not ROZ)
    struct hwr_t                s_hwr;          //all physical registers supporting HW writes
    struct hwdata_t             s_hwdata;       //all physical registers supporting HW writes  

    xlen_t                      s_rdata;        //read mux output for all physical registers
    uint1                       s_access_err;   //read error mux output for all physical registers
    uint1                       s_read_only;    //read only mux output for all physical registers
    $$for(i = 0; i < 16; i++)
    uint1                       s_pmpaddr$$(i)_en;
    $$endfor()


//-------- AUTOGEN BEGIN (wire_declare) --------
    uint_<{XLEN}>    s_rdata_fcsr;
    uint_<{XLEN}>    s_rdata_stvec;
    uint_<{XLEN}>    s_rdata_scounteren;
    uint_<{XLEN}>    s_rdata_senvcfg;
    uint_<{XLEN}>    s_rdata_sscratch;
    uint_<{XLEN}>    s_rdata_sepc;
    uint_<{XLEN}>    s_rdata_scause;
    uint_<{XLEN}>    s_rdata_stval;
    uint_<{XLEN}>    s_rdata_satp;
    uint_<{XLEN}>    s_rdata_mstatus;
    uint_<{XLEN}>    s_rdata_misa;
    uint_<{XLEN}>    s_rdata_medeleg;
    uint_<{XLEN}>    s_rdata_mideleg;
    uint_<{XLEN}>    s_rdata_mie;
    uint_<{XLEN}>    s_rdata_mtvec;
    uint_<{XLEN}>    s_rdata_mcounteren;
    uint_<{XLEN}>    s_rdata_menvcfg;
    uint_<{XLEN}>    s_rdata_mcountinhibit;
    uint_<{XLEN}>    s_rdata_mhpmevent3;
    uint_<{XLEN}>    s_rdata_mhpmevent4;
    uint_<{XLEN}>    s_rdata_mhpmevent5;
    uint_<{XLEN}>    s_rdata_mhpmevent6;
    uint_<{XLEN}>    s_rdata_mhpmevent7;
    uint_<{XLEN}>    s_rdata_mhpmevent8;
    uint_<{XLEN}>    s_rdata_mhpmevent9;
    uint_<{XLEN}>    s_rdata_mhpmevent10;
    uint_<{XLEN}>    s_rdata_mhpmevent11;
    uint_<{XLEN}>    s_rdata_mhpmevent12;
    uint_<{XLEN}>    s_rdata_mhpmevent13;
    uint_<{XLEN}>    s_rdata_mhpmevent14;
    uint_<{XLEN}>    s_rdata_mhpmevent15;
    uint_<{XLEN}>    s_rdata_mhpmevent16;
    uint_<{XLEN}>    s_rdata_mhpmevent17;
    uint_<{XLEN}>    s_rdata_mhpmevent18;
    uint_<{XLEN}>    s_rdata_mhpmevent19;
    uint_<{XLEN}>    s_rdata_mhpmevent20;
    uint_<{XLEN}>    s_rdata_mhpmevent21;
    uint_<{XLEN}>    s_rdata_mhpmevent22;
    uint_<{XLEN}>    s_rdata_mhpmevent23;
    uint_<{XLEN}>    s_rdata_mhpmevent24;
    uint_<{XLEN}>    s_rdata_mhpmevent25;
    uint_<{XLEN}>    s_rdata_mhpmevent26;
    uint_<{XLEN}>    s_rdata_mhpmevent27;
    uint_<{XLEN}>    s_rdata_mhpmevent28;
    uint_<{XLEN}>    s_rdata_mhpmevent29;
    uint_<{XLEN}>    s_rdata_mhpmevent30;
    uint_<{XLEN}>    s_rdata_mhpmevent31;
    uint_<{XLEN}>    s_rdata_mscratch;
    uint_<{XLEN}>    s_rdata_mepc;
    uint_<{XLEN}>    s_rdata_mcause;
    uint_<{XLEN}>    s_rdata_mtval;
    uint_<{XLEN}>    s_rdata_mip;
    uint_<{XLEN}>    s_rdata_pmpcfg0;
    uint_<{XLEN}>    s_rdata_pmpcfg2;
    uint_<{XLEN}>    s_rdata_pmpcfg4;
    uint_<{XLEN}>    s_rdata_pmpcfg6;
    uint_<{XLEN}>    s_rdata_pmpcfg8;
    uint_<{XLEN}>    s_rdata_pmpcfg10;
    uint_<{XLEN}>    s_rdata_pmpcfg12;
    uint_<{XLEN}>    s_rdata_pmpcfg14;
    uint_<{XLEN}>    s_rdata_pmpaddr0;
    uint_<{XLEN}>    s_rdata_pmpaddr1;
    uint_<{XLEN}>    s_rdata_pmpaddr2;
    uint_<{XLEN}>    s_rdata_pmpaddr3;
    uint_<{XLEN}>    s_rdata_pmpaddr4;
    uint_<{XLEN}>    s_rdata_pmpaddr5;
    uint_<{XLEN}>    s_rdata_pmpaddr6;
    uint_<{XLEN}>    s_rdata_pmpaddr7;
    uint_<{XLEN}>    s_rdata_pmpaddr8;
    uint_<{XLEN}>    s_rdata_pmpaddr9;
    uint_<{XLEN}>    s_rdata_pmpaddr10;
    uint_<{XLEN}>    s_rdata_pmpaddr11;
    uint_<{XLEN}>    s_rdata_pmpaddr12;
    uint_<{XLEN}>    s_rdata_pmpaddr13;
    uint_<{XLEN}>    s_rdata_pmpaddr14;
    uint_<{XLEN}>    s_rdata_pmpaddr15;
    uint_<{XLEN}>    s_rdata_pmpaddr16;
    uint_<{XLEN}>    s_rdata_pmpaddr17;
    uint_<{XLEN}>    s_rdata_pmpaddr18;
    uint_<{XLEN}>    s_rdata_pmpaddr19;
    uint_<{XLEN}>    s_rdata_pmpaddr20;
    uint_<{XLEN}>    s_rdata_pmpaddr21;
    uint_<{XLEN}>    s_rdata_pmpaddr22;
    uint_<{XLEN}>    s_rdata_pmpaddr23;
    uint_<{XLEN}>    s_rdata_pmpaddr24;
    uint_<{XLEN}>    s_rdata_pmpaddr25;
    uint_<{XLEN}>    s_rdata_pmpaddr26;
    uint_<{XLEN}>    s_rdata_pmpaddr27;
    uint_<{XLEN}>    s_rdata_pmpaddr28;
    uint_<{XLEN}>    s_rdata_pmpaddr29;
    uint_<{XLEN}>    s_rdata_pmpaddr30;
    uint_<{XLEN}>    s_rdata_pmpaddr31;
    uint_<{XLEN}>    s_rdata_pmpaddr32;
    uint_<{XLEN}>    s_rdata_pmpaddr33;
    uint_<{XLEN}>    s_rdata_pmpaddr34;
    uint_<{XLEN}>    s_rdata_pmpaddr35;
    uint_<{XLEN}>    s_rdata_pmpaddr36;
    uint_<{XLEN}>    s_rdata_pmpaddr37;
    uint_<{XLEN}>    s_rdata_pmpaddr38;
    uint_<{XLEN}>    s_rdata_pmpaddr39;
    uint_<{XLEN}>    s_rdata_pmpaddr40;
    uint_<{XLEN}>    s_rdata_pmpaddr41;
    uint_<{XLEN}>    s_rdata_pmpaddr42;
    uint_<{XLEN}>    s_rdata_pmpaddr43;
    uint_<{XLEN}>    s_rdata_pmpaddr44;
    uint_<{XLEN}>    s_rdata_pmpaddr45;
    uint_<{XLEN}>    s_rdata_pmpaddr46;
    uint_<{XLEN}>    s_rdata_pmpaddr47;
    uint_<{XLEN}>    s_rdata_pmpaddr48;
    uint_<{XLEN}>    s_rdata_pmpaddr49;
    uint_<{XLEN}>    s_rdata_pmpaddr50;
    uint_<{XLEN}>    s_rdata_pmpaddr51;
    uint_<{XLEN}>    s_rdata_pmpaddr52;
    uint_<{XLEN}>    s_rdata_pmpaddr53;
    uint_<{XLEN}>    s_rdata_pmpaddr54;
    uint_<{XLEN}>    s_rdata_pmpaddr55;
    uint_<{XLEN}>    s_rdata_pmpaddr56;
    uint_<{XLEN}>    s_rdata_pmpaddr57;
    uint_<{XLEN}>    s_rdata_pmpaddr58;
    uint_<{XLEN}>    s_rdata_pmpaddr59;
    uint_<{XLEN}>    s_rdata_pmpaddr60;
    uint_<{XLEN}>    s_rdata_pmpaddr61;
    uint_<{XLEN}>    s_rdata_pmpaddr62;
    uint_<{XLEN}>    s_rdata_pmpaddr63;
    uint_<{XLEN}>    s_rdata_sbpredctrl;
    uint_<{XLEN}>    s_rdata_tselect;
    uint_<{XLEN}>    s_rdata_tdata1;
    uint_<{XLEN}>    s_rdata_tdata2;
    uint_<{XLEN}>    s_rdata_tinfo;
    uint_<{XLEN}>    s_rdata_dcsr;
    uint_<{XLEN}>    s_rdata_dpc;
    uint_<{XLEN}>    s_rdata_dscratch0;
    uint_<{XLEN}>    s_rdata_dscratch1;
    uint_<{XLEN}>    s_rdata_mcfgctrl;
    uint_<{XLEN}>    s_rdata_mcachestatus;
    uint_<{XLEN}>    s_rdata_mdcachectrl;
    uint_<{XLEN}>    s_rdata_micachectrl;
    uint_<{XLEN}>    s_rdata_mcycle;
    uint_<{XLEN}>    s_rdata_minstret;
    uint_<{XLEN}>    s_rdata_mhpmcounter3;
    uint_<{XLEN}>    s_rdata_mhpmcounter4;
    uint_<{XLEN}>    s_rdata_mhpmcounter5;
    uint_<{XLEN}>    s_rdata_mhpmcounter6;
    uint_<{XLEN}>    s_rdata_mhpmcounter7;
    uint_<{XLEN}>    s_rdata_mhpmcounter8;
    uint_<{XLEN}>    s_rdata_mhpmcounter9;
    uint_<{XLEN}>    s_rdata_mhpmcounter10;
    uint_<{XLEN}>    s_rdata_mhpmcounter11;
    uint_<{XLEN}>    s_rdata_mhpmcounter12;
    uint_<{XLEN}>    s_rdata_mhpmcounter13;
    uint_<{XLEN}>    s_rdata_mhpmcounter14;
    uint_<{XLEN}>    s_rdata_mhpmcounter15;
    uint_<{XLEN}>    s_rdata_mhpmcounter16;
    uint_<{XLEN}>    s_rdata_mhpmcounter17;
    uint_<{XLEN}>    s_rdata_mhpmcounter18;
    uint_<{XLEN}>    s_rdata_mhpmcounter19;
    uint_<{XLEN}>    s_rdata_mhpmcounter20;
    uint_<{XLEN}>    s_rdata_mhpmcounter21;
    uint_<{XLEN}>    s_rdata_mhpmcounter22;
    uint_<{XLEN}>    s_rdata_mhpmcounter23;
    uint_<{XLEN}>    s_rdata_mhpmcounter24;
    uint_<{XLEN}>    s_rdata_mhpmcounter25;
    uint_<{XLEN}>    s_rdata_mhpmcounter26;
    uint_<{XLEN}>    s_rdata_mhpmcounter27;
    uint_<{XLEN}>    s_rdata_mhpmcounter28;
    uint_<{XLEN}>    s_rdata_mhpmcounter29;
    uint_<{XLEN}>    s_rdata_mhpmcounter30;
    uint_<{XLEN}>    s_rdata_mhpmcounter31;
    uint_<{XLEN}>    s_rdata_mvendorid;
    uint_<{XLEN}>    s_rdata_marchid;
    uint_<{XLEN}>    s_rdata_mimpid;
    uint_<{XLEN}>    s_rdata_mhartid;
    uint_<{XLEN}>    s_rdata_mconfigptr;
#if (OPTION_XLEN == 64)
    uint_<{XLEN}>    s_rdata_vstart;
    uint_<{XLEN}>    s_rdata_vcsr;
    uint_<{XLEN}>    s_rdata_ml2cachectrl;
    uint_<{XLEN}>    s_rdata_vl;
    uint_<{XLEN}>    s_rdata_vtype;
    uint_<{XLEN}>    s_rdata_vlenb;
#endif //(OPTION_XLEN == 64)
#if (OPTION_XLEN == 32)
    uint_<{XLEN}>    s_rdata_mstatush;
    uint_<{XLEN}>    s_rdata_menvcfgh;
    uint_<{XLEN}>    s_rdata_pmpcfg1;
    uint_<{XLEN}>    s_rdata_pmpcfg3;
    uint_<{XLEN}>    s_rdata_pmpcfg5;
    uint_<{XLEN}>    s_rdata_pmpcfg7;
    uint_<{XLEN}>    s_rdata_pmpcfg9;
    uint_<{XLEN}>    s_rdata_pmpcfg11;
    uint_<{XLEN}>    s_rdata_pmpcfg13;
    uint_<{XLEN}>    s_rdata_pmpcfg15;
    uint_<{XLEN}>    s_rdata_mcycleh;
    uint_<{XLEN}>    s_rdata_minstreth;
    uint_<{XLEN}>    s_rdata_mhpmcounter3h;
    uint_<{XLEN}>    s_rdata_mhpmcounter4h;
    uint_<{XLEN}>    s_rdata_mhpmcounter5h;
    uint_<{XLEN}>    s_rdata_mhpmcounter6h;
    uint_<{XLEN}>    s_rdata_mhpmcounter7h;
    uint_<{XLEN}>    s_rdata_mhpmcounter8h;
    uint_<{XLEN}>    s_rdata_mhpmcounter9h;
    uint_<{XLEN}>    s_rdata_mhpmcounter10h;
    uint_<{XLEN}>    s_rdata_mhpmcounter11h;
    uint_<{XLEN}>    s_rdata_mhpmcounter12h;
    uint_<{XLEN}>    s_rdata_mhpmcounter13h;
    uint_<{XLEN}>    s_rdata_mhpmcounter14h;
    uint_<{XLEN}>    s_rdata_mhpmcounter15h;
    uint_<{XLEN}>    s_rdata_mhpmcounter16h;
    uint_<{XLEN}>    s_rdata_mhpmcounter17h;
    uint_<{XLEN}>    s_rdata_mhpmcounter18h;
    uint_<{XLEN}>    s_rdata_mhpmcounter19h;
    uint_<{XLEN}>    s_rdata_mhpmcounter20h;
    uint_<{XLEN}>    s_rdata_mhpmcounter21h;
    uint_<{XLEN}>    s_rdata_mhpmcounter22h;
    uint_<{XLEN}>    s_rdata_mhpmcounter23h;
    uint_<{XLEN}>    s_rdata_mhpmcounter24h;
    uint_<{XLEN}>    s_rdata_mhpmcounter25h;
    uint_<{XLEN}>    s_rdata_mhpmcounter26h;
    uint_<{XLEN}>    s_rdata_mhpmcounter27h;
    uint_<{XLEN}>    s_rdata_mhpmcounter28h;
    uint_<{XLEN}>    s_rdata_mhpmcounter29h;
    uint_<{XLEN}>    s_rdata_mhpmcounter30h;
    uint_<{XLEN}>    s_rdata_mhpmcounter31h;
#endif //(OPTION_XLEN == 32)
//-------- AUTOGEN END (wire_declare) --------

    uint1                       s_ex3_flush;
    uint1                       s_ex1_stall;
    uint1                       s_ex2_stall;

    enum csr_mode               s_prv_mode;
    uint1                       s_dbg_mode;

    uint1                       s_read_ex2;
    uint12                      s_raddr_ex2; //12-bit space excluding CHERI SCRs
    xlen_t                      s_rdata_ex2;
    uint1                       s_write_ex3;
    uint12                      s_waddr_ex3; //12-bit space excluding CHERI SCRs
    xlen_t                      s_wdata_ex3;

    //plc instructions
    uint1                       s_instr_ebreak_ex1;
    uint1                       s_instr_ecall_ex1;
    uint1                       s_instr_dret_ex1;
    uint1                       s_instr_mret_ex1;
    uint1                       s_instr_sret_ex1;
    uint1                       s_instr_wfi_ex1;

    //mcachestatus
    uint1                       s_mcachestatus_icache_disabled_val;
    uint1                       s_mcachestatus_icache_pref_disabled_val;
    uint1                       s_mcachestatus_dcache_disabled_val;
    uint1                       s_mcachestatus_dcache_pref_disabled_val;
    uint1                       s_mcachestatus_l2cache_disabled_val;
    uint1                       s_mcachestatus_wfi_stop_mode_val;
    
    //hw updates
    uint1                       s_vcsr_vxsat_we; //TODO: VPU to write vxsat
    uint1                       s_vcsr_vxsat_val;
    uint1                       s_sstatus_vs_we; //TODO: VPU to write VS
    uint2                       s_sstatus_vs_val;
    uint_<{clog2(TRIGGERS)}>    s_hwidx_tdata1;

    //plc
    uint1                       s_csr_instr_ebreak_ex2;
    uint1                       s_csr_instr_ecall_ex2;
    uint1                       s_csr_instr_mret_ex2;
    uint1                       s_csr_instr_sret_ex2;
    uint1                       s_csr_instr_dret_ex2;
    uint1                       s_csr_instr_wfi_ex2;

    uint1                       s_top_mip_ssip_we;    //implemented in set_mip()
    uint1                       s_top_mip_ssip_val;   //implemented in set_mip()
    uint1                       s_top_mip_msip_we;    //implemented in set_mip()
    uint1                       s_top_mip_msip_val;   //implemented in set_mip()
    uint1                       s_top_mip_stip_we;    //implemented in set_mip()
    uint1                       s_top_mip_stip_val;   //implemented in set_mip()
    uint1                       s_top_mip_mtip_we;    //implemented in set_mip()
    uint1                       s_top_mip_mtip_val;   //implemented in set_mip()
    uint1                       s_top_mip_seip_we;    //implemented in set_mip()
    uint1                       s_top_mip_seip_val;   //implemented in set_mip()
    uint1                       s_top_mip_meip_we;    //implemented in set_mip()
    uint1                       s_top_mip_meip_val;   //implemented in set_mip()

    uint1                       s_plc_mip_ssip_we;    //implemented in set_updt_csr()
    uint1                       s_plc_mip_ssip_val;   //implemented in set_updt_csr()
    uint1                       s_plc_mip_msip_we;    //implemented in set_updt_csr()
    uint1                       s_plc_mip_msip_val;   //implemented in set_updt_csr()
    uint1                       s_plc_mip_stip_we;    //implemented in set_updt_csr()
    uint1                       s_plc_mip_stip_val;   //implemented in set_updt_csr()
    uint1                       s_plc_mip_mtip_we;    //implemented in set_updt_csr()
    uint1                       s_plc_mip_mtip_val;   //implemented in set_updt_csr()
    uint1                       s_plc_mip_seip_we;    //implemented in set_updt_csr()
    uint1                       s_plc_mip_seip_val;   //implemented in set_updt_csr()
    uint1                       s_plc_mip_meip_we;    //implemented in set_updt_csr()
    uint1                       s_plc_mip_meip_val;   //implemented in set_updt_csr()

    //csr exception
    uint1                       s_dbg_only_err_ex1;
    uint1                       s_csr_read_err_ex2; //read disabled or unsupported registers
    uint1                       s_csr_read_only_ex2;
    uint1                       s_read_err_ex2;
    uint1                       s_write_err_ex2;    
    uint1                       s_fflags_en;
    uint1                       s_frm_en;
    uint1                       s_fcsr_en;
#if (OPTION_XLEN == 64)
    uint1                       s_vstart_en; //signal are used when EXTENSION_V is defined
    uint1                       s_vxsat_en;
    uint1                       s_vxrm_en;
    uint1                       s_vcsr_en;
#endif
    uint1                       s_pmpcfg0_en;
    uint1                       s_pmpcfg2_en;
    uint1                       s_pmpcfg4_en;
    uint1                       s_pmpcfg6_en;
#if (OPTION_XLEN == 32)
    uint1                       s_pmpcfg1_en;
    uint1                       s_pmpcfg3_en;
    uint1                       s_pmpcfg5_en;
    uint1                       s_pmpcfg7_en;
#endif
    uint16                      s_pmpaddr_15_0_en;
    uint1                       s_cycle_en;
    uint1                       s_time_en;
    uint1                       s_instret_en;
    uint4                       s_hpmcounter_6_3_en;
    uint25                      s_hpmcounter_31_7_en;
#if (OPTION_XLEN == 64)
    uint1                       s_vl_en;
    uint1                       s_vtype_en;
    uint1                       s_vlenb_en;
#endif

    //for shadow registers
    uint12                      s_shdw_raddr;
    uint1                       s_shdw_read_err;
    uint64                      s_mtime;
    uint1                       s_shdw_rd_time;
#if (OPTION_XLEN == 32)
    uint1                       s_shdw_rd_timeh;
#endif
    uint1                       s_shdw_read_only;
    uint1                       s_shdw_dbg_reg;
    uint1                       s_shdw_dbg_reg_ex3;

    //triggers
    pc_t                        s_i0_pc_ex1;
    uint1                       s_i0_vld_ex1;
    pc_t                        s_i1_pc_ex1;
    uint1                       s_i1_vld_ex1;
    pc_t                        s_ls_addr_ex1; 
    uint1                       s_ls_vld_ex1;
    uint1                       s_is_i1_ex1;
    uint1                       s_is_store_ex1;
    uint1                       s_set_hit;

    uint2                       s_op_mode;

    uint1                       s_trigger_flush_i0;
    uint1                       s_trigger_flush_i1;

    //ex1 signals
    uint1                       s_trigger_match;
    uint1                       s_trigger_type;
    uint1                       s_trigger_is_i1;
    uint3                       s_trigger_action;
    uint_<{clog2(TRIGGERS)}>    s_trigger_idx;

    //ex2 signals
    uint1                       s_trigger_match_ex2; //TODO, sample s_trigger_match
    uint1                       s_trigger_type_ex2;  //TODO
    uint1                       s_trigger_is_i1_ex2; //TODO
    uint4                       s_trigger_action_ex2;//TODO
   
    //debug
    xlen_t                      s_ddata0;

//////////////////// Start of CHERI ////////////////////
#ifdef OPTION_HAS_CHERI
    //SCR registers
    register xlen_t             r_ddc;  //0x1001
    register xlen_t             r_stdc; //0x100d
    register xlen_t             r_mtdc; //0x101d

    //wires
    uint1                       s_ccu_excep_ex3_i0; //TODO: connect
    uint1                       s_scr_read_ex2;
    csr_addr_t                  s_scr_raddr_ex2;
    uint1                       s_scr_read_err_ex2;
    xlen_t                      s_scr_rdata_ex2;
    xlen_t                      s_rdata_mux;
    uint1                       s_csr_write_ex3;
    uint1                       s_scr_xdc_write_ex3;

#endif
//////////////////// End of CHERI ////////////////////

// ********************************************************************************************
//  Initialize variables
// ********************************************************************************************

// ********************************************************************************************
//  Read/Write Processing (Register Patterns)
// ********************************************************************************************

    automatic void proc_reg_io (void)
    {
        s_hwr = (bit struct hwr_t)(uint_<{bitsizeof(hwr_t)}>)0;
        //s_hwr.vcsr = 0;           //TODO: drive them
        //s_hwr.mcachestatus = 0;   //TODO: drive them

        s_swdata = s_wdata_ex3;
    }

//-------- Manual begin (reg_proc) --------/
    //// Pattern 3S: SRW-HW, STRUCT(with sparse wpri bits presented)
    //automatic void proc_dcsr(void) {
    //    // Read
    //    s_rdata.dcsr = (bit uint_<{bitsizeof(dcsr_t)}>)r_dcsr;
    //    // Write
    //    if (s_swr.dcsr)
    //    {
    //        r_dcsr = (bit struct dcsr_t)s_swdata[bitsizeof(dcsr_t)-1..0];
    //    } 
    //    else if (s_hwr.dcsr)
    //    {
    //        r_dcsr = (bit struct dcsr_t)s_hwdata.dcsr[bitsizeof(dcsr_t)-1..0];
    //    }
    //}

    //signal conversion
    automatic void signal_conv(void) {
        int i;
        $$for(i = 0; i < 16; i++)
            s_pmpaddr$$(i)_en = s_pmpaddr_15_0_en[$$(i)];
        $$endfor()
    }

    // Pattern 2S: SRO-HW, STRUCT
    automatic void proc_mcachestatus(void) {
        // Read
        s_rdata_mcachestatus = m_data_conv.struct_rdata_unpack_mcachestatus(r_mcachestatus);
        // Write
        r_mcachestatus.icache_disabled      = s_mcachestatus_icache_disabled_val;
        r_mcachestatus.icache_pref_disabled = s_mcachestatus_icache_pref_disabled_val;
        r_mcachestatus.dcache_disabled      = s_mcachestatus_dcache_disabled_val;
        r_mcachestatus.dcache_pref_disabled = s_mcachestatus_dcache_pref_disabled_val;
        r_mcachestatus.l2cache_disabled     = s_mcachestatus_l2cache_disabled_val;
        r_mcachestatus.wfi_stop_mode        = s_mcachestatus_wfi_stop_mode_val;
    }

    // Pattern 3S: SRW-HW, STRUCT
    automatic void proc_scause(void) {
        // Read
        s_rdata_scause = m_data_conv.struct_rdata_unpack_scause(r_scause);
        // Write
        if (s_swr.scause)
            r_scause = m_data_conv.struct_wdata_pack_scause(s_swdata);
        else if (s_hwr.scause)
            r_scause = m_data_conv.struct_wdata_pack_scause(s_hwdata.scause);
    }

    // Pattern 3S: SRW-HW, STRUCT
    automatic void proc_mstatus(void) {
        // Read
        s_rdata_mstatus = m_data_conv.struct_rdata_unpack_mstatus(r_mstatus);
        // Write
        if (s_swr.mstatus)
            r_mstatus = m_data_conv.struct_wdata_pack_mstatus(s_swdata);
        else if (s_hwr.mstatus)
            r_mstatus = m_data_conv.struct_wdata_pack_mstatus(s_hwdata.mstatus);
    }

    // Pattern 3S: SRW-HW, STRUCT
    automatic void proc_mip(void) {
        // Read
        s_rdata_mip = m_data_conv.struct_rdata_unpack_mip(r_mip);
        // Write
        if (s_swr.mip)
            r_mip = m_data_conv.struct_wdata_pack_mip(s_swdata);
        else if (s_hwr.mip)
            r_mip = m_data_conv.struct_wdata_pack_mip(s_hwdata.mip);
    }

    // Pattern 3S: SRW-HW, STRUCT
    automatic void proc_mcause(void) {
        // Read
        s_rdata_mcause = m_data_conv.struct_rdata_unpack_mcause(r_mcause);
        // Write
        if (s_swr.mcause)
            r_mcause = m_data_conv.struct_wdata_pack_mcause(s_swdata);
        else if (s_hwr.mcause)
            r_mcause = m_data_conv.struct_wdata_pack_mcause(s_hwdata.mcause);
    }

//-------- Manual end (reg_proc) --------


//-------- AUTOGEN BEGIN (reg_proc) --------
    // Pattern 3S: SRW-HW, STRUCT
    automatic void proc_fcsr(void) {
        // Read
        s_rdata_fcsr = m_data_conv.struct_rdata_unpack_fcsr(r_fcsr);
        // Write
        if (s_swr.fcsr)
            r_fcsr = m_data_conv.struct_wdata_pack_fcsr(s_swdata);
        else if (s_hwr.fcsr)
            r_fcsr = m_data_conv.struct_wdata_pack_fcsr(s_hwdata.fcsr);
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_stvec(void) {
        // Read
        s_rdata_stvec = m_data_conv.struct_rdata_unpack_stvec(r_stvec);
        // Write
        if (s_swr.stvec)
            r_stvec = m_data_conv.struct_wdata_pack_stvec(s_swdata);
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_scounteren(void) {
        // Read
        s_rdata_scounteren = m_data_conv.struct_rdata_unpack_scounteren(r_scounteren);
        // Write
        if (s_swr.scounteren)
            r_scounteren = m_data_conv.struct_wdata_pack_scounteren(s_swdata);
    }

    // Pattern 1: SRW, XLEN
    automatic void proc_senvcfg(void) {
        // Read
        s_rdata_senvcfg = r_senvcfg;
        // Write
        if (s_swr.senvcfg)
            r_senvcfg = s_swdata;
    }

    // Pattern 1: SRW, XLEN
    automatic void proc_sscratch(void) {
        // Read
        s_rdata_sscratch = r_sscratch;
        // Write
        if (s_swr.sscratch)
            r_sscratch = s_swdata;
    }

    // Pattern 3S: SRW-HW, STRUCT
    automatic void proc_sepc(void) {
        // Read
        s_rdata_sepc = m_data_conv.struct_rdata_unpack_sepc(r_sepc);
        // Write
        if (s_swr.sepc)
            r_sepc = m_data_conv.struct_wdata_pack_sepc(s_swdata);
        else if (s_hwr.sepc)
            r_sepc = m_data_conv.struct_wdata_pack_sepc(s_hwdata.sepc);
    }

    // Pattern 3: SRW-HW, XLEN
    automatic void proc_stval(void) {
        // Read
        s_rdata_stval = r_stval;
        // Write
        if (s_swr.stval)
            r_stval = s_swdata;
        else if (s_hwr.stval)
            r_stval = s_hwdata.stval;
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_satp(void) {
        // Read
        s_rdata_satp = m_data_conv.struct_rdata_unpack_satp(r_satp);
        // Write
        if (s_swr.satp)
            r_satp = m_data_conv.struct_wdata_pack_satp(s_swdata);
    }

    // Pattern 5S: SRO-Preset, STRUCT
    automatic void proc_misa(void) {
        // Read
        s_rdata_misa = m_data_conv.struct_rdata_unpack_misa(r_misa);
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_medeleg(void) {
        // Read
        s_rdata_medeleg = m_data_conv.struct_rdata_unpack_medeleg(r_medeleg);
        // Write
        if (s_swr.medeleg)
            r_medeleg = m_data_conv.struct_wdata_pack_medeleg(s_swdata);
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_mideleg(void) {
        // Read
        s_rdata_mideleg = m_data_conv.struct_rdata_unpack_mideleg(r_mideleg);
        // Write
        if (s_swr.mideleg)
            r_mideleg = m_data_conv.struct_wdata_pack_mideleg(s_swdata);
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_mie(void) {
        // Read
        s_rdata_mie = m_data_conv.struct_rdata_unpack_mie(r_mie);
        // Write
        if (s_swr.mie)
            r_mie = m_data_conv.struct_wdata_pack_mie(s_swdata);
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_mtvec(void) {
        // Read
        s_rdata_mtvec = m_data_conv.struct_rdata_unpack_mtvec(r_mtvec);
        // Write
        if (s_swr.mtvec)
            r_mtvec = m_data_conv.struct_wdata_pack_mtvec(s_swdata);
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_mcounteren(void) {
        // Read
        s_rdata_mcounteren = m_data_conv.struct_rdata_unpack_mcounteren(r_mcounteren);
        // Write
        if (s_swr.mcounteren)
            r_mcounteren = m_data_conv.struct_wdata_pack_mcounteren(s_swdata);
    }

    // Pattern 1: SRW, XLEN
    automatic void proc_menvcfg(void) {
        // Read
        s_rdata_menvcfg = r_menvcfg;
        // Write
        if (s_swr.menvcfg)
            r_menvcfg = s_swdata;
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_mcountinhibit(void) {
        // Read
        s_rdata_mcountinhibit = m_data_conv.struct_rdata_unpack_mcountinhibit(r_mcountinhibit);
        // Write
        if (s_swr.mcountinhibit)
            r_mcountinhibit = m_data_conv.struct_wdata_pack_mcountinhibit(s_swdata);
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_mhpmevent3(void) {
        // Read
        s_rdata_mhpmevent3 = m_data_conv.struct_rdata_unpack_mhpmevent3(r_mhpmevent3);
        // Write
        if (s_swr.mhpmevent3)
            r_mhpmevent3 = m_data_conv.struct_wdata_pack_mhpmevent3(s_swdata);
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_mhpmevent4(void) {
        // Read
        s_rdata_mhpmevent4 = m_data_conv.struct_rdata_unpack_mhpmevent4(r_mhpmevent4);
        // Write
        if (s_swr.mhpmevent4)
            r_mhpmevent4 = m_data_conv.struct_wdata_pack_mhpmevent4(s_swdata);
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_mhpmevent5(void) {
        // Read
        s_rdata_mhpmevent5 = m_data_conv.struct_rdata_unpack_mhpmevent5(r_mhpmevent5);
        // Write
        if (s_swr.mhpmevent5)
            r_mhpmevent5 = m_data_conv.struct_wdata_pack_mhpmevent5(s_swdata);
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_mhpmevent6(void) {
        // Read
        s_rdata_mhpmevent6 = m_data_conv.struct_rdata_unpack_mhpmevent6(r_mhpmevent6);
        // Write
        if (s_swr.mhpmevent6)
            r_mhpmevent6 = m_data_conv.struct_wdata_pack_mhpmevent6(s_swdata);
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent7(void) {
        // Read
        s_rdata_mhpmevent7 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent8(void) {
        // Read
        s_rdata_mhpmevent8 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent9(void) {
        // Read
        s_rdata_mhpmevent9 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent10(void) {
        // Read
        s_rdata_mhpmevent10 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent11(void) {
        // Read
        s_rdata_mhpmevent11 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent12(void) {
        // Read
        s_rdata_mhpmevent12 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent13(void) {
        // Read
        s_rdata_mhpmevent13 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent14(void) {
        // Read
        s_rdata_mhpmevent14 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent15(void) {
        // Read
        s_rdata_mhpmevent15 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent16(void) {
        // Read
        s_rdata_mhpmevent16 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent17(void) {
        // Read
        s_rdata_mhpmevent17 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent18(void) {
        // Read
        s_rdata_mhpmevent18 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent19(void) {
        // Read
        s_rdata_mhpmevent19 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent20(void) {
        // Read
        s_rdata_mhpmevent20 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent21(void) {
        // Read
        s_rdata_mhpmevent21 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent22(void) {
        // Read
        s_rdata_mhpmevent22 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent23(void) {
        // Read
        s_rdata_mhpmevent23 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent24(void) {
        // Read
        s_rdata_mhpmevent24 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent25(void) {
        // Read
        s_rdata_mhpmevent25 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent26(void) {
        // Read
        s_rdata_mhpmevent26 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent27(void) {
        // Read
        s_rdata_mhpmevent27 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent28(void) {
        // Read
        s_rdata_mhpmevent28 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent29(void) {
        // Read
        s_rdata_mhpmevent29 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent30(void) {
        // Read
        s_rdata_mhpmevent30 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmevent31(void) {
        // Read
        s_rdata_mhpmevent31 = 0;
    }

    // Pattern 1: SRW, XLEN
    automatic void proc_mscratch(void) {
        // Read
        s_rdata_mscratch = r_mscratch;
        // Write
        if (s_swr.mscratch)
            r_mscratch = s_swdata;
    }

    // Pattern 3S: SRW-HW, STRUCT
    automatic void proc_mepc(void) {
        // Read
        s_rdata_mepc = m_data_conv.struct_rdata_unpack_mepc(r_mepc);
        // Write
        if (s_swr.mepc)
            r_mepc = m_data_conv.struct_wdata_pack_mepc(s_swdata);
        else if (s_hwr.mepc)
            r_mepc = m_data_conv.struct_wdata_pack_mepc(s_hwdata.mepc);
    }

    // Pattern 3: SRW-HW, XLEN
    automatic void proc_mtval(void) {
        // Read
        s_rdata_mtval = r_mtval;
        // Write
        if (s_swr.mtval)
            r_mtval = s_swdata;
        else if (s_hwr.mtval)
            r_mtval = s_hwdata.mtval;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpcfg0(void) {
        // Read
        if (s_pmpcfg0_en)
            s_rdata_pmpcfg0 = r_pmpcfg0;
        else
            s_rdata_pmpcfg0 = 0;
        // Write
        if (s_swr.pmpcfg0)
            r_pmpcfg0 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpcfg2(void) {
        // Read
        if (s_pmpcfg2_en)
            s_rdata_pmpcfg2 = r_pmpcfg2;
        else
            s_rdata_pmpcfg2 = 0;
        // Write
        if (s_swr.pmpcfg2)
            r_pmpcfg2 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpcfg4(void) {
        // Read
        if (s_pmpcfg4_en)
            s_rdata_pmpcfg4 = r_pmpcfg4;
        else
            s_rdata_pmpcfg4 = 0;
        // Write
        if (s_swr.pmpcfg4)
            r_pmpcfg4 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpcfg6(void) {
        // Read
        if (s_pmpcfg6_en)
            s_rdata_pmpcfg6 = r_pmpcfg6;
        else
            s_rdata_pmpcfg6 = 0;
        // Write
        if (s_swr.pmpcfg6)
            r_pmpcfg6 = s_swdata;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpcfg8(void) {
        // Read
        s_rdata_pmpcfg8 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpcfg10(void) {
        // Read
        s_rdata_pmpcfg10 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpcfg12(void) {
        // Read
        s_rdata_pmpcfg12 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpcfg14(void) {
        // Read
        s_rdata_pmpcfg14 = 0;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpaddr0(void) {
        // Read
        if (s_pmpaddr0_en)
            s_rdata_pmpaddr0 = r_pmpaddr0;
        else
            s_rdata_pmpaddr0 = 0;
        // Write
        if (s_swr.pmpaddr0)
            r_pmpaddr0 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpaddr1(void) {
        // Read
        if (s_pmpaddr1_en)
            s_rdata_pmpaddr1 = r_pmpaddr1;
        else
            s_rdata_pmpaddr1 = 0;
        // Write
        if (s_swr.pmpaddr1)
            r_pmpaddr1 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpaddr2(void) {
        // Read
        if (s_pmpaddr2_en)
            s_rdata_pmpaddr2 = r_pmpaddr2;
        else
            s_rdata_pmpaddr2 = 0;
        // Write
        if (s_swr.pmpaddr2)
            r_pmpaddr2 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpaddr3(void) {
        // Read
        if (s_pmpaddr3_en)
            s_rdata_pmpaddr3 = r_pmpaddr3;
        else
            s_rdata_pmpaddr3 = 0;
        // Write
        if (s_swr.pmpaddr3)
            r_pmpaddr3 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpaddr4(void) {
        // Read
        if (s_pmpaddr4_en)
            s_rdata_pmpaddr4 = r_pmpaddr4;
        else
            s_rdata_pmpaddr4 = 0;
        // Write
        if (s_swr.pmpaddr4)
            r_pmpaddr4 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpaddr5(void) {
        // Read
        if (s_pmpaddr5_en)
            s_rdata_pmpaddr5 = r_pmpaddr5;
        else
            s_rdata_pmpaddr5 = 0;
        // Write
        if (s_swr.pmpaddr5)
            r_pmpaddr5 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpaddr6(void) {
        // Read
        if (s_pmpaddr6_en)
            s_rdata_pmpaddr6 = r_pmpaddr6;
        else
            s_rdata_pmpaddr6 = 0;
        // Write
        if (s_swr.pmpaddr6)
            r_pmpaddr6 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpaddr7(void) {
        // Read
        if (s_pmpaddr7_en)
            s_rdata_pmpaddr7 = r_pmpaddr7;
        else
            s_rdata_pmpaddr7 = 0;
        // Write
        if (s_swr.pmpaddr7)
            r_pmpaddr7 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpaddr8(void) {
        // Read
        if (s_pmpaddr8_en)
            s_rdata_pmpaddr8 = r_pmpaddr8;
        else
            s_rdata_pmpaddr8 = 0;
        // Write
        if (s_swr.pmpaddr8)
            r_pmpaddr8 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpaddr9(void) {
        // Read
        if (s_pmpaddr9_en)
            s_rdata_pmpaddr9 = r_pmpaddr9;
        else
            s_rdata_pmpaddr9 = 0;
        // Write
        if (s_swr.pmpaddr9)
            r_pmpaddr9 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpaddr10(void) {
        // Read
        if (s_pmpaddr10_en)
            s_rdata_pmpaddr10 = r_pmpaddr10;
        else
            s_rdata_pmpaddr10 = 0;
        // Write
        if (s_swr.pmpaddr10)
            r_pmpaddr10 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpaddr11(void) {
        // Read
        if (s_pmpaddr11_en)
            s_rdata_pmpaddr11 = r_pmpaddr11;
        else
            s_rdata_pmpaddr11 = 0;
        // Write
        if (s_swr.pmpaddr11)
            r_pmpaddr11 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpaddr12(void) {
        // Read
        if (s_pmpaddr12_en)
            s_rdata_pmpaddr12 = r_pmpaddr12;
        else
            s_rdata_pmpaddr12 = 0;
        // Write
        if (s_swr.pmpaddr12)
            r_pmpaddr12 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpaddr13(void) {
        // Read
        if (s_pmpaddr13_en)
            s_rdata_pmpaddr13 = r_pmpaddr13;
        else
            s_rdata_pmpaddr13 = 0;
        // Write
        if (s_swr.pmpaddr13)
            r_pmpaddr13 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpaddr14(void) {
        // Read
        if (s_pmpaddr14_en)
            s_rdata_pmpaddr14 = r_pmpaddr14;
        else
            s_rdata_pmpaddr14 = 0;
        // Write
        if (s_swr.pmpaddr14)
            r_pmpaddr14 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpaddr15(void) {
        // Read
        if (s_pmpaddr15_en)
            s_rdata_pmpaddr15 = r_pmpaddr15;
        else
            s_rdata_pmpaddr15 = 0;
        // Write
        if (s_swr.pmpaddr15)
            r_pmpaddr15 = s_swdata;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr16(void) {
        // Read
        s_rdata_pmpaddr16 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr17(void) {
        // Read
        s_rdata_pmpaddr17 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr18(void) {
        // Read
        s_rdata_pmpaddr18 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr19(void) {
        // Read
        s_rdata_pmpaddr19 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr20(void) {
        // Read
        s_rdata_pmpaddr20 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr21(void) {
        // Read
        s_rdata_pmpaddr21 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr22(void) {
        // Read
        s_rdata_pmpaddr22 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr23(void) {
        // Read
        s_rdata_pmpaddr23 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr24(void) {
        // Read
        s_rdata_pmpaddr24 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr25(void) {
        // Read
        s_rdata_pmpaddr25 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr26(void) {
        // Read
        s_rdata_pmpaddr26 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr27(void) {
        // Read
        s_rdata_pmpaddr27 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr28(void) {
        // Read
        s_rdata_pmpaddr28 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr29(void) {
        // Read
        s_rdata_pmpaddr29 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr30(void) {
        // Read
        s_rdata_pmpaddr30 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr31(void) {
        // Read
        s_rdata_pmpaddr31 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr32(void) {
        // Read
        s_rdata_pmpaddr32 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr33(void) {
        // Read
        s_rdata_pmpaddr33 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr34(void) {
        // Read
        s_rdata_pmpaddr34 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr35(void) {
        // Read
        s_rdata_pmpaddr35 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr36(void) {
        // Read
        s_rdata_pmpaddr36 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr37(void) {
        // Read
        s_rdata_pmpaddr37 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr38(void) {
        // Read
        s_rdata_pmpaddr38 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr39(void) {
        // Read
        s_rdata_pmpaddr39 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr40(void) {
        // Read
        s_rdata_pmpaddr40 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr41(void) {
        // Read
        s_rdata_pmpaddr41 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr42(void) {
        // Read
        s_rdata_pmpaddr42 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr43(void) {
        // Read
        s_rdata_pmpaddr43 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr44(void) {
        // Read
        s_rdata_pmpaddr44 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr45(void) {
        // Read
        s_rdata_pmpaddr45 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr46(void) {
        // Read
        s_rdata_pmpaddr46 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr47(void) {
        // Read
        s_rdata_pmpaddr47 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr48(void) {
        // Read
        s_rdata_pmpaddr48 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr49(void) {
        // Read
        s_rdata_pmpaddr49 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr50(void) {
        // Read
        s_rdata_pmpaddr50 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr51(void) {
        // Read
        s_rdata_pmpaddr51 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr52(void) {
        // Read
        s_rdata_pmpaddr52 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr53(void) {
        // Read
        s_rdata_pmpaddr53 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr54(void) {
        // Read
        s_rdata_pmpaddr54 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr55(void) {
        // Read
        s_rdata_pmpaddr55 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr56(void) {
        // Read
        s_rdata_pmpaddr56 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr57(void) {
        // Read
        s_rdata_pmpaddr57 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr58(void) {
        // Read
        s_rdata_pmpaddr58 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr59(void) {
        // Read
        s_rdata_pmpaddr59 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr60(void) {
        // Read
        s_rdata_pmpaddr60 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr61(void) {
        // Read
        s_rdata_pmpaddr61 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr62(void) {
        // Read
        s_rdata_pmpaddr62 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpaddr63(void) {
        // Read
        s_rdata_pmpaddr63 = 0;
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_sbpredctrl(void) {
        // Read
        s_rdata_sbpredctrl = m_data_conv.struct_rdata_unpack_sbpredctrl(r_sbpredctrl);
        // Write
        if (s_swr.sbpredctrl)
            r_sbpredctrl = m_data_conv.struct_wdata_pack_sbpredctrl(s_swdata);
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_tselect(void) {
        // Read
        s_rdata_tselect = m_data_conv.struct_rdata_unpack_tselect(r_tselect);
        // Write
        if (s_swr.tselect)
            r_tselect = m_data_conv.struct_wdata_pack_tselect(s_swdata);
    }

    // Pattern 3T: SRW-HW, XLEN, tdata1
    automatic void proc_tdata1(void) {
        // Read
        s_rdata_tdata1 = r_tdata1[r_tselect.idx];
        // Write
        if (s_swr.tdata1)
            r_tdata1[r_tselect.idx] = s_swdata;
        else if (s_hwr.tdata1)
            r_tdata1[s_hwidx_tdata1] = s_hwdata.tdata1;
    }

    // Pattern 1T: SRW, XLEN, tdata2
    automatic void proc_tdata2(void) {
        // Read
        s_rdata_tdata2 = r_tdata2[r_tselect.idx];
        // Write
        if (s_swr.tdata2)
            r_tdata2[r_tselect.idx] = s_swdata;
    }

    // Pattern 1: SRW, XLEN
    automatic void proc_tinfo(void) {
        // Read
        s_rdata_tinfo = r_tinfo;
        // Write
        if (s_swr.tinfo)
            r_tinfo = s_swdata;
    }

    // Pattern 3S: SRW-HW, STRUCT
    automatic void proc_dcsr(void) {
        // Read
        s_rdata_dcsr = m_data_conv.struct_rdata_unpack_dcsr(r_dcsr);
        // Write
        if (s_swr.dcsr)
            r_dcsr = m_data_conv.struct_wdata_pack_dcsr(s_swdata);
        else if (s_hwr.dcsr)
            r_dcsr = m_data_conv.struct_wdata_pack_dcsr(s_hwdata.dcsr);
    }

    // Pattern 3S: SRW-HW, STRUCT
    automatic void proc_dpc(void) {
        // Read
        s_rdata_dpc = m_data_conv.struct_rdata_unpack_dpc(r_dpc);
        // Write
        if (s_swr.dpc)
            r_dpc = m_data_conv.struct_wdata_pack_dpc(s_swdata);
        else if (s_hwr.dpc)
            r_dpc = m_data_conv.struct_wdata_pack_dpc(s_hwdata.dpc);
    }

    // Pattern 1: SRW, XLEN
    automatic void proc_dscratch0(void) {
        // Read
        s_rdata_dscratch0 = r_dscratch0;
        // Write
        if (s_swr.dscratch0)
            r_dscratch0 = s_swdata;
    }

    // Pattern 1: SRW, XLEN
    automatic void proc_dscratch1(void) {
        // Read
        s_rdata_dscratch1 = r_dscratch1;
        // Write
        if (s_swr.dscratch1)
            r_dscratch1 = s_swdata;
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_mcfgctrl(void) {
        // Read
        s_rdata_mcfgctrl = m_data_conv.struct_rdata_unpack_mcfgctrl(r_mcfgctrl);
        // Write
        if (s_swr.mcfgctrl)
            r_mcfgctrl = m_data_conv.struct_wdata_pack_mcfgctrl(s_swdata);
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_mdcachectrl(void) {
        // Read
        s_rdata_mdcachectrl = m_data_conv.struct_rdata_unpack_mdcachectrl(r_mdcachectrl);
        // Write
        if (s_swr.mdcachectrl)
            r_mdcachectrl = m_data_conv.struct_wdata_pack_mdcachectrl(s_swdata);
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_micachectrl(void) {
        // Read
        s_rdata_micachectrl = m_data_conv.struct_rdata_unpack_micachectrl(r_micachectrl);
        // Write
        if (s_swr.micachectrl)
            r_micachectrl = m_data_conv.struct_wdata_pack_micachectrl(s_swdata);
    }

    // Pattern 3: SRW-HW, XLEN
    automatic void proc_mcycle(void) {
        // Read
        s_rdata_mcycle = r_mcycle;
        // Write
        if (s_swr.mcycle)
            r_mcycle = s_swdata;
        else if (s_hwr.mcycle)
            r_mcycle = s_hwdata.mcycle;
    }

    // Pattern 3: SRW-HW, XLEN
    automatic void proc_minstret(void) {
        // Read
        s_rdata_minstret = r_minstret;
        // Write
        if (s_swr.minstret)
            r_minstret = s_swdata;
        else if (s_hwr.minstret)
            r_minstret = s_hwdata.minstret;
    }

    // Pattern 3: SRW-HW, XLEN
    automatic void proc_mhpmcounter3(void) {
        // Read
        s_rdata_mhpmcounter3 = r_mhpmcounter3;
        // Write
        if (s_swr.mhpmcounter3)
            r_mhpmcounter3 = s_swdata;
        else if (s_hwr.mhpmcounter3)
            r_mhpmcounter3 = s_hwdata.mhpmcounter3;
    }

    // Pattern 3: SRW-HW, XLEN
    automatic void proc_mhpmcounter4(void) {
        // Read
        s_rdata_mhpmcounter4 = r_mhpmcounter4;
        // Write
        if (s_swr.mhpmcounter4)
            r_mhpmcounter4 = s_swdata;
        else if (s_hwr.mhpmcounter4)
            r_mhpmcounter4 = s_hwdata.mhpmcounter4;
    }

    // Pattern 3: SRW-HW, XLEN
    automatic void proc_mhpmcounter5(void) {
        // Read
        s_rdata_mhpmcounter5 = r_mhpmcounter5;
        // Write
        if (s_swr.mhpmcounter5)
            r_mhpmcounter5 = s_swdata;
        else if (s_hwr.mhpmcounter5)
            r_mhpmcounter5 = s_hwdata.mhpmcounter5;
    }

    // Pattern 3: SRW-HW, XLEN
    automatic void proc_mhpmcounter6(void) {
        // Read
        s_rdata_mhpmcounter6 = r_mhpmcounter6;
        // Write
        if (s_swr.mhpmcounter6)
            r_mhpmcounter6 = s_swdata;
        else if (s_hwr.mhpmcounter6)
            r_mhpmcounter6 = s_hwdata.mhpmcounter6;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter7(void) {
        // Read
        s_rdata_mhpmcounter7 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter8(void) {
        // Read
        s_rdata_mhpmcounter8 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter9(void) {
        // Read
        s_rdata_mhpmcounter9 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter10(void) {
        // Read
        s_rdata_mhpmcounter10 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter11(void) {
        // Read
        s_rdata_mhpmcounter11 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter12(void) {
        // Read
        s_rdata_mhpmcounter12 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter13(void) {
        // Read
        s_rdata_mhpmcounter13 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter14(void) {
        // Read
        s_rdata_mhpmcounter14 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter15(void) {
        // Read
        s_rdata_mhpmcounter15 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter16(void) {
        // Read
        s_rdata_mhpmcounter16 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter17(void) {
        // Read
        s_rdata_mhpmcounter17 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter18(void) {
        // Read
        s_rdata_mhpmcounter18 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter19(void) {
        // Read
        s_rdata_mhpmcounter19 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter20(void) {
        // Read
        s_rdata_mhpmcounter20 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter21(void) {
        // Read
        s_rdata_mhpmcounter21 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter22(void) {
        // Read
        s_rdata_mhpmcounter22 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter23(void) {
        // Read
        s_rdata_mhpmcounter23 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter24(void) {
        // Read
        s_rdata_mhpmcounter24 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter25(void) {
        // Read
        s_rdata_mhpmcounter25 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter26(void) {
        // Read
        s_rdata_mhpmcounter26 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter27(void) {
        // Read
        s_rdata_mhpmcounter27 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter28(void) {
        // Read
        s_rdata_mhpmcounter28 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter29(void) {
        // Read
        s_rdata_mhpmcounter29 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter30(void) {
        // Read
        s_rdata_mhpmcounter30 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter31(void) {
        // Read
        s_rdata_mhpmcounter31 = 0;
    }

    // Pattern 5: SRO-Preset, XLEN
    automatic void proc_mvendorid(void) {
        // Read
        s_rdata_mvendorid = r_mvendorid;
    }

    // Pattern 5S: SRO-Preset, STRUCT
    automatic void proc_marchid(void) {
        // Read
        s_rdata_marchid = m_data_conv.struct_rdata_unpack_marchid(r_marchid);
    }

    // Pattern 5: SRO-Preset, XLEN
    automatic void proc_mimpid(void) {
        // Read
        s_rdata_mimpid = r_mimpid;
    }

    // Pattern 2: SRO-HW, XLEN
    automatic void proc_mhartid(void) {
        // Read
        s_rdata_mhartid = r_mhartid;
        // Write
        if (s_hwr.mhartid)
            r_mhartid = s_hwdata.mhartid;
    }

    // Pattern 2: SRO-HW, XLEN
    automatic void proc_mconfigptr(void) {
        // Read
        s_rdata_mconfigptr = r_mconfigptr;
        // Write
        if (s_hwr.mconfigptr)
            r_mconfigptr = s_hwdata.mconfigptr;
    }

#if (OPTION_XLEN == 64)
    // Pattern 1: SRW, XLEN
    automatic void proc_vstart(void) {
        // Read
        s_rdata_vstart = r_vstart;
        // Write
        if (s_swr.vstart)
            r_vstart = s_swdata;
    }

    // Pattern 3S: SRW-HW, STRUCT
    automatic void proc_vcsr(void) {
        // Read
        s_rdata_vcsr = m_data_conv.struct_rdata_unpack_vcsr(r_vcsr);
        // Write
        if (s_swr.vcsr)
            r_vcsr = m_data_conv.struct_wdata_pack_vcsr(s_swdata);
        else if (s_hwr.vcsr)
            r_vcsr = m_data_conv.struct_wdata_pack_vcsr(s_hwdata.vcsr);
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_ml2cachectrl(void) {
        // Read
        s_rdata_ml2cachectrl = m_data_conv.struct_rdata_unpack_ml2cachectrl(r_ml2cachectrl);
        // Write
        if (s_swr.ml2cachectrl)
            r_ml2cachectrl = m_data_conv.struct_wdata_pack_ml2cachectrl(s_swdata);
    }

    // Pattern 5: SRO-Preset, XLEN
    automatic void proc_vl(void) {
        // Read
        s_rdata_vl = r_vl;
    }

    // Pattern 5S: SRO-Preset, STRUCT
    automatic void proc_vtype(void) {
        // Read
        s_rdata_vtype = m_data_conv.struct_rdata_unpack_vtype(r_vtype);
    }

    // Pattern 5: SRO-Preset, XLEN
    automatic void proc_vlenb(void) {
        // Read
        s_rdata_vlenb = r_vlenb;
    }

#endif //(OPTION_XLEN == 64)
#if (OPTION_XLEN == 32)
    // Pattern 3S: SRW-HW, STRUCT
    automatic void proc_mstatush(void) {
        // Read
        s_rdata_mstatush = m_data_conv.struct_rdata_unpack_mstatush(r_mstatush);
        // Write
        if (s_swr.mstatush)
            r_mstatush = m_data_conv.struct_wdata_pack_mstatush(s_swdata);
        else if (s_hwr.mstatush)
            r_mstatush = m_data_conv.struct_wdata_pack_mstatush(s_hwdata.mstatush);
    }

    // Pattern 1S: SRW, STRUCT
    automatic void proc_menvcfgh(void) {
        // Read
        s_rdata_menvcfgh = m_data_conv.struct_rdata_unpack_menvcfgh(r_menvcfgh);
        // Write
        if (s_swr.menvcfgh)
            r_menvcfgh = m_data_conv.struct_wdata_pack_menvcfgh(s_swdata);
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpcfg1(void) {
        // Read
        if (s_pmpcfg1_en)
            s_rdata_pmpcfg1 = r_pmpcfg1;
        else
            s_rdata_pmpcfg1 = 0;
        // Write
        if (s_swr.pmpcfg1)
            r_pmpcfg1 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpcfg3(void) {
        // Read
        if (s_pmpcfg3_en)
            s_rdata_pmpcfg3 = r_pmpcfg3;
        else
            s_rdata_pmpcfg3 = 0;
        // Write
        if (s_swr.pmpcfg3)
            r_pmpcfg3 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpcfg5(void) {
        // Read
        if (s_pmpcfg5_en)
            s_rdata_pmpcfg5 = r_pmpcfg5;
        else
            s_rdata_pmpcfg5 = 0;
        // Write
        if (s_swr.pmpcfg5)
            r_pmpcfg5 = s_swdata;
    }

    // Pattern 1E: SRW + RD-EN/ROZ, XLEN
    automatic void proc_pmpcfg7(void) {
        // Read
        if (s_pmpcfg7_en)
            s_rdata_pmpcfg7 = r_pmpcfg7;
        else
            s_rdata_pmpcfg7 = 0;
        // Write
        if (s_swr.pmpcfg7)
            r_pmpcfg7 = s_swdata;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpcfg9(void) {
        // Read
        s_rdata_pmpcfg9 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpcfg11(void) {
        // Read
        s_rdata_pmpcfg11 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpcfg13(void) {
        // Read
        s_rdata_pmpcfg13 = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_pmpcfg15(void) {
        // Read
        s_rdata_pmpcfg15 = 0;
    }

    // Pattern 3: SRW-HW, XLEN
    automatic void proc_mcycleh(void) {
        // Read
        s_rdata_mcycleh = r_mcycleh;
        // Write
        if (s_swr.mcycleh)
            r_mcycleh = s_swdata;
        else if (s_hwr.mcycleh)
            r_mcycleh = s_hwdata.mcycleh;
    }

    // Pattern 3: SRW-HW, XLEN
    automatic void proc_minstreth(void) {
        // Read
        s_rdata_minstreth = r_minstreth;
        // Write
        if (s_swr.minstreth)
            r_minstreth = s_swdata;
        else if (s_hwr.minstreth)
            r_minstreth = s_hwdata.minstreth;
    }

    // Pattern 3: SRW-HW, XLEN
    automatic void proc_mhpmcounter3h(void) {
        // Read
        s_rdata_mhpmcounter3h = r_mhpmcounter3h;
        // Write
        if (s_swr.mhpmcounter3h)
            r_mhpmcounter3h = s_swdata;
        else if (s_hwr.mhpmcounter3h)
            r_mhpmcounter3h = s_hwdata.mhpmcounter3h;
    }

    // Pattern 3: SRW-HW, XLEN
    automatic void proc_mhpmcounter4h(void) {
        // Read
        s_rdata_mhpmcounter4h = r_mhpmcounter4h;
        // Write
        if (s_swr.mhpmcounter4h)
            r_mhpmcounter4h = s_swdata;
        else if (s_hwr.mhpmcounter4h)
            r_mhpmcounter4h = s_hwdata.mhpmcounter4h;
    }

    // Pattern 3: SRW-HW, XLEN
    automatic void proc_mhpmcounter5h(void) {
        // Read
        s_rdata_mhpmcounter5h = r_mhpmcounter5h;
        // Write
        if (s_swr.mhpmcounter5h)
            r_mhpmcounter5h = s_swdata;
        else if (s_hwr.mhpmcounter5h)
            r_mhpmcounter5h = s_hwdata.mhpmcounter5h;
    }

    // Pattern 3: SRW-HW, XLEN
    automatic void proc_mhpmcounter6h(void) {
        // Read
        s_rdata_mhpmcounter6h = r_mhpmcounter6h;
        // Write
        if (s_swr.mhpmcounter6h)
            r_mhpmcounter6h = s_swdata;
        else if (s_hwr.mhpmcounter6h)
            r_mhpmcounter6h = s_hwdata.mhpmcounter6h;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter7h(void) {
        // Read
        s_rdata_mhpmcounter7h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter8h(void) {
        // Read
        s_rdata_mhpmcounter8h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter9h(void) {
        // Read
        s_rdata_mhpmcounter9h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter10h(void) {
        // Read
        s_rdata_mhpmcounter10h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter11h(void) {
        // Read
        s_rdata_mhpmcounter11h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter12h(void) {
        // Read
        s_rdata_mhpmcounter12h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter13h(void) {
        // Read
        s_rdata_mhpmcounter13h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter14h(void) {
        // Read
        s_rdata_mhpmcounter14h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter15h(void) {
        // Read
        s_rdata_mhpmcounter15h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter16h(void) {
        // Read
        s_rdata_mhpmcounter16h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter17h(void) {
        // Read
        s_rdata_mhpmcounter17h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter18h(void) {
        // Read
        s_rdata_mhpmcounter18h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter19h(void) {
        // Read
        s_rdata_mhpmcounter19h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter20h(void) {
        // Read
        s_rdata_mhpmcounter20h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter21h(void) {
        // Read
        s_rdata_mhpmcounter21h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter22h(void) {
        // Read
        s_rdata_mhpmcounter22h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter23h(void) {
        // Read
        s_rdata_mhpmcounter23h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter24h(void) {
        // Read
        s_rdata_mhpmcounter24h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter25h(void) {
        // Read
        s_rdata_mhpmcounter25h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter26h(void) {
        // Read
        s_rdata_mhpmcounter26h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter27h(void) {
        // Read
        s_rdata_mhpmcounter27h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter28h(void) {
        // Read
        s_rdata_mhpmcounter28h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter29h(void) {
        // Read
        s_rdata_mhpmcounter29h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter30h(void) {
        // Read
        s_rdata_mhpmcounter30h = 0;
    }

    // Pattern 4: ROZ, XLEN
    automatic void proc_mhpmcounter31h(void) {
        // Read
        s_rdata_mhpmcounter31h = 0;
    }

#endif //(OPTION_XLEN == 32)
//-------- AUTOGEN END (reg_proc) --------

// ********************************************************************************************
//  Read/Write Processing (Read MUXes and Write decoder)
// ********************************************************************************************
    // ----------------------------------------------------------------------------------------
    // Private Function - Read Data MUX (EX2)
    // ----------------------------------------------------------------------------------------
    // Input: s_raddr_ex2, s_rdata.<regNameX>[XLEN-1..0]
    // Output: rdata[XLEN-1..0]

    automatic void proc_read_mux(void) {
        switch (s_raddr_ex2) {
            //list all physical registers, excl. shadow & cheri xdc
//-------- AUTOGEN BEGIN (rdata_mux) --------
            case CSR_FCSR:                  s_rdata = s_rdata_fcsr;             break;
            case CSR_STVEC:                 s_rdata = s_rdata_stvec;            break;
            case CSR_SCOUNTEREN:            s_rdata = s_rdata_scounteren;       break;
            case CSR_SENVCFG:               s_rdata = s_rdata_senvcfg;          break;
            case CSR_SSCRATCH:              s_rdata = s_rdata_sscratch;         break;
            case CSR_SEPC:                  s_rdata = s_rdata_sepc;             break;
            case CSR_SCAUSE:                s_rdata = s_rdata_scause;           break;
            case CSR_STVAL:                 s_rdata = s_rdata_stval;            break;
            case CSR_SATP:                  s_rdata = s_rdata_satp;             break;
            case CSR_MSTATUS:               s_rdata = s_rdata_mstatus;          break;
            case CSR_MISA:                  s_rdata = s_rdata_misa;             break;
            case CSR_MEDELEG:               s_rdata = s_rdata_medeleg;          break;
            case CSR_MIDELEG:               s_rdata = s_rdata_mideleg;          break;
            case CSR_MIE:                   s_rdata = s_rdata_mie;              break;
            case CSR_MTVEC:                 s_rdata = s_rdata_mtvec;            break;
            case CSR_MCOUNTEREN:            s_rdata = s_rdata_mcounteren;       break;
            case CSR_MENVCFG:               s_rdata = s_rdata_menvcfg;          break;
            case CSR_MCOUNTINHIBIT:         s_rdata = s_rdata_mcountinhibit;    break;
            case CSR_MHPMEVENT3:            s_rdata = s_rdata_mhpmevent3;       break;
            case CSR_MHPMEVENT4:            s_rdata = s_rdata_mhpmevent4;       break;
            case CSR_MHPMEVENT5:            s_rdata = s_rdata_mhpmevent5;       break;
            case CSR_MHPMEVENT6:            s_rdata = s_rdata_mhpmevent6;       break;
            case CSR_MHPMEVENT7:            s_rdata = s_rdata_mhpmevent7;       break;
            case CSR_MHPMEVENT8:            s_rdata = s_rdata_mhpmevent8;       break;
            case CSR_MHPMEVENT9:            s_rdata = s_rdata_mhpmevent9;       break;
            case CSR_MHPMEVENT10:           s_rdata = s_rdata_mhpmevent10;      break;
            case CSR_MHPMEVENT11:           s_rdata = s_rdata_mhpmevent11;      break;
            case CSR_MHPMEVENT12:           s_rdata = s_rdata_mhpmevent12;      break;
            case CSR_MHPMEVENT13:           s_rdata = s_rdata_mhpmevent13;      break;
            case CSR_MHPMEVENT14:           s_rdata = s_rdata_mhpmevent14;      break;
            case CSR_MHPMEVENT15:           s_rdata = s_rdata_mhpmevent15;      break;
            case CSR_MHPMEVENT16:           s_rdata = s_rdata_mhpmevent16;      break;
            case CSR_MHPMEVENT17:           s_rdata = s_rdata_mhpmevent17;      break;
            case CSR_MHPMEVENT18:           s_rdata = s_rdata_mhpmevent18;      break;
            case CSR_MHPMEVENT19:           s_rdata = s_rdata_mhpmevent19;      break;
            case CSR_MHPMEVENT20:           s_rdata = s_rdata_mhpmevent20;      break;
            case CSR_MHPMEVENT21:           s_rdata = s_rdata_mhpmevent21;      break;
            case CSR_MHPMEVENT22:           s_rdata = s_rdata_mhpmevent22;      break;
            case CSR_MHPMEVENT23:           s_rdata = s_rdata_mhpmevent23;      break;
            case CSR_MHPMEVENT24:           s_rdata = s_rdata_mhpmevent24;      break;
            case CSR_MHPMEVENT25:           s_rdata = s_rdata_mhpmevent25;      break;
            case CSR_MHPMEVENT26:           s_rdata = s_rdata_mhpmevent26;      break;
            case CSR_MHPMEVENT27:           s_rdata = s_rdata_mhpmevent27;      break;
            case CSR_MHPMEVENT28:           s_rdata = s_rdata_mhpmevent28;      break;
            case CSR_MHPMEVENT29:           s_rdata = s_rdata_mhpmevent29;      break;
            case CSR_MHPMEVENT30:           s_rdata = s_rdata_mhpmevent30;      break;
            case CSR_MHPMEVENT31:           s_rdata = s_rdata_mhpmevent31;      break;
            case CSR_MSCRATCH:              s_rdata = s_rdata_mscratch;         break;
            case CSR_MEPC:                  s_rdata = s_rdata_mepc;             break;
            case CSR_MCAUSE:                s_rdata = s_rdata_mcause;           break;
            case CSR_MTVAL:                 s_rdata = s_rdata_mtval;            break;
            case CSR_MIP:                   s_rdata = s_rdata_mip;              break;
            case CSR_PMPCFG0:               s_rdata = s_rdata_pmpcfg0;          break;
            case CSR_PMPCFG2:               s_rdata = s_rdata_pmpcfg2;          break;
            case CSR_PMPCFG4:               s_rdata = s_rdata_pmpcfg4;          break;
            case CSR_PMPCFG6:               s_rdata = s_rdata_pmpcfg6;          break;
            case CSR_PMPCFG8:               s_rdata = s_rdata_pmpcfg8;          break;
            case CSR_PMPCFG10:              s_rdata = s_rdata_pmpcfg10;         break;
            case CSR_PMPCFG12:              s_rdata = s_rdata_pmpcfg12;         break;
            case CSR_PMPCFG14:              s_rdata = s_rdata_pmpcfg14;         break;
            case CSR_PMPADDR0:              s_rdata = s_rdata_pmpaddr0;         break;
            case CSR_PMPADDR1:              s_rdata = s_rdata_pmpaddr1;         break;
            case CSR_PMPADDR2:              s_rdata = s_rdata_pmpaddr2;         break;
            case CSR_PMPADDR3:              s_rdata = s_rdata_pmpaddr3;         break;
            case CSR_PMPADDR4:              s_rdata = s_rdata_pmpaddr4;         break;
            case CSR_PMPADDR5:              s_rdata = s_rdata_pmpaddr5;         break;
            case CSR_PMPADDR6:              s_rdata = s_rdata_pmpaddr6;         break;
            case CSR_PMPADDR7:              s_rdata = s_rdata_pmpaddr7;         break;
            case CSR_PMPADDR8:              s_rdata = s_rdata_pmpaddr8;         break;
            case CSR_PMPADDR9:              s_rdata = s_rdata_pmpaddr9;         break;
            case CSR_PMPADDR10:             s_rdata = s_rdata_pmpaddr10;        break;
            case CSR_PMPADDR11:             s_rdata = s_rdata_pmpaddr11;        break;
            case CSR_PMPADDR12:             s_rdata = s_rdata_pmpaddr12;        break;
            case CSR_PMPADDR13:             s_rdata = s_rdata_pmpaddr13;        break;
            case CSR_PMPADDR14:             s_rdata = s_rdata_pmpaddr14;        break;
            case CSR_PMPADDR15:             s_rdata = s_rdata_pmpaddr15;        break;
            case CSR_PMPADDR16:             s_rdata = s_rdata_pmpaddr16;        break;
            case CSR_PMPADDR17:             s_rdata = s_rdata_pmpaddr17;        break;
            case CSR_PMPADDR18:             s_rdata = s_rdata_pmpaddr18;        break;
            case CSR_PMPADDR19:             s_rdata = s_rdata_pmpaddr19;        break;
            case CSR_PMPADDR20:             s_rdata = s_rdata_pmpaddr20;        break;
            case CSR_PMPADDR21:             s_rdata = s_rdata_pmpaddr21;        break;
            case CSR_PMPADDR22:             s_rdata = s_rdata_pmpaddr22;        break;
            case CSR_PMPADDR23:             s_rdata = s_rdata_pmpaddr23;        break;
            case CSR_PMPADDR24:             s_rdata = s_rdata_pmpaddr24;        break;
            case CSR_PMPADDR25:             s_rdata = s_rdata_pmpaddr25;        break;
            case CSR_PMPADDR26:             s_rdata = s_rdata_pmpaddr26;        break;
            case CSR_PMPADDR27:             s_rdata = s_rdata_pmpaddr27;        break;
            case CSR_PMPADDR28:             s_rdata = s_rdata_pmpaddr28;        break;
            case CSR_PMPADDR29:             s_rdata = s_rdata_pmpaddr29;        break;
            case CSR_PMPADDR30:             s_rdata = s_rdata_pmpaddr30;        break;
            case CSR_PMPADDR31:             s_rdata = s_rdata_pmpaddr31;        break;
            case CSR_PMPADDR32:             s_rdata = s_rdata_pmpaddr32;        break;
            case CSR_PMPADDR33:             s_rdata = s_rdata_pmpaddr33;        break;
            case CSR_PMPADDR34:             s_rdata = s_rdata_pmpaddr34;        break;
            case CSR_PMPADDR35:             s_rdata = s_rdata_pmpaddr35;        break;
            case CSR_PMPADDR36:             s_rdata = s_rdata_pmpaddr36;        break;
            case CSR_PMPADDR37:             s_rdata = s_rdata_pmpaddr37;        break;
            case CSR_PMPADDR38:             s_rdata = s_rdata_pmpaddr38;        break;
            case CSR_PMPADDR39:             s_rdata = s_rdata_pmpaddr39;        break;
            case CSR_PMPADDR40:             s_rdata = s_rdata_pmpaddr40;        break;
            case CSR_PMPADDR41:             s_rdata = s_rdata_pmpaddr41;        break;
            case CSR_PMPADDR42:             s_rdata = s_rdata_pmpaddr42;        break;
            case CSR_PMPADDR43:             s_rdata = s_rdata_pmpaddr43;        break;
            case CSR_PMPADDR44:             s_rdata = s_rdata_pmpaddr44;        break;
            case CSR_PMPADDR45:             s_rdata = s_rdata_pmpaddr45;        break;
            case CSR_PMPADDR46:             s_rdata = s_rdata_pmpaddr46;        break;
            case CSR_PMPADDR47:             s_rdata = s_rdata_pmpaddr47;        break;
            case CSR_PMPADDR48:             s_rdata = s_rdata_pmpaddr48;        break;
            case CSR_PMPADDR49:             s_rdata = s_rdata_pmpaddr49;        break;
            case CSR_PMPADDR50:             s_rdata = s_rdata_pmpaddr50;        break;
            case CSR_PMPADDR51:             s_rdata = s_rdata_pmpaddr51;        break;
            case CSR_PMPADDR52:             s_rdata = s_rdata_pmpaddr52;        break;
            case CSR_PMPADDR53:             s_rdata = s_rdata_pmpaddr53;        break;
            case CSR_PMPADDR54:             s_rdata = s_rdata_pmpaddr54;        break;
            case CSR_PMPADDR55:             s_rdata = s_rdata_pmpaddr55;        break;
            case CSR_PMPADDR56:             s_rdata = s_rdata_pmpaddr56;        break;
            case CSR_PMPADDR57:             s_rdata = s_rdata_pmpaddr57;        break;
            case CSR_PMPADDR58:             s_rdata = s_rdata_pmpaddr58;        break;
            case CSR_PMPADDR59:             s_rdata = s_rdata_pmpaddr59;        break;
            case CSR_PMPADDR60:             s_rdata = s_rdata_pmpaddr60;        break;
            case CSR_PMPADDR61:             s_rdata = s_rdata_pmpaddr61;        break;
            case CSR_PMPADDR62:             s_rdata = s_rdata_pmpaddr62;        break;
            case CSR_PMPADDR63:             s_rdata = s_rdata_pmpaddr63;        break;
            case CSR_SBPREDCTRL:            s_rdata = s_rdata_sbpredctrl;       break;
            case CSR_TSELECT:               s_rdata = s_rdata_tselect;          break;
            case CSR_TDATA1:                s_rdata = s_rdata_tdata1;           break;
            case CSR_TDATA2:                s_rdata = s_rdata_tdata2;           break;
            case CSR_TINFO:                 s_rdata = s_rdata_tinfo;            break;
            case CSR_DCSR:                  s_rdata = s_rdata_dcsr;             break;
            case CSR_DPC:                   s_rdata = s_rdata_dpc;              break;
            case CSR_DSCRATCH0:             s_rdata = s_rdata_dscratch0;        break;
            case CSR_DSCRATCH1:             s_rdata = s_rdata_dscratch1;        break;
            case CSR_MCFGCTRL:              s_rdata = s_rdata_mcfgctrl;         break;
            case CSR_MCACHESTATUS:          s_rdata = s_rdata_mcachestatus;     break;
            case CSR_MDCACHECTRL:           s_rdata = s_rdata_mdcachectrl;      break;
            case CSR_MICACHECTRL:           s_rdata = s_rdata_micachectrl;      break;
            case CSR_MCYCLE:                s_rdata = s_rdata_mcycle;           break;
            case CSR_MINSTRET:              s_rdata = s_rdata_minstret;         break;
            case CSR_MHPMCOUNTER3:          s_rdata = s_rdata_mhpmcounter3;     break;
            case CSR_MHPMCOUNTER4:          s_rdata = s_rdata_mhpmcounter4;     break;
            case CSR_MHPMCOUNTER5:          s_rdata = s_rdata_mhpmcounter5;     break;
            case CSR_MHPMCOUNTER6:          s_rdata = s_rdata_mhpmcounter6;     break;
            case CSR_MHPMCOUNTER7:          s_rdata = s_rdata_mhpmcounter7;     break;
            case CSR_MHPMCOUNTER8:          s_rdata = s_rdata_mhpmcounter8;     break;
            case CSR_MHPMCOUNTER9:          s_rdata = s_rdata_mhpmcounter9;     break;
            case CSR_MHPMCOUNTER10:         s_rdata = s_rdata_mhpmcounter10;    break;
            case CSR_MHPMCOUNTER11:         s_rdata = s_rdata_mhpmcounter11;    break;
            case CSR_MHPMCOUNTER12:         s_rdata = s_rdata_mhpmcounter12;    break;
            case CSR_MHPMCOUNTER13:         s_rdata = s_rdata_mhpmcounter13;    break;
            case CSR_MHPMCOUNTER14:         s_rdata = s_rdata_mhpmcounter14;    break;
            case CSR_MHPMCOUNTER15:         s_rdata = s_rdata_mhpmcounter15;    break;
            case CSR_MHPMCOUNTER16:         s_rdata = s_rdata_mhpmcounter16;    break;
            case CSR_MHPMCOUNTER17:         s_rdata = s_rdata_mhpmcounter17;    break;
            case CSR_MHPMCOUNTER18:         s_rdata = s_rdata_mhpmcounter18;    break;
            case CSR_MHPMCOUNTER19:         s_rdata = s_rdata_mhpmcounter19;    break;
            case CSR_MHPMCOUNTER20:         s_rdata = s_rdata_mhpmcounter20;    break;
            case CSR_MHPMCOUNTER21:         s_rdata = s_rdata_mhpmcounter21;    break;
            case CSR_MHPMCOUNTER22:         s_rdata = s_rdata_mhpmcounter22;    break;
            case CSR_MHPMCOUNTER23:         s_rdata = s_rdata_mhpmcounter23;    break;
            case CSR_MHPMCOUNTER24:         s_rdata = s_rdata_mhpmcounter24;    break;
            case CSR_MHPMCOUNTER25:         s_rdata = s_rdata_mhpmcounter25;    break;
            case CSR_MHPMCOUNTER26:         s_rdata = s_rdata_mhpmcounter26;    break;
            case CSR_MHPMCOUNTER27:         s_rdata = s_rdata_mhpmcounter27;    break;
            case CSR_MHPMCOUNTER28:         s_rdata = s_rdata_mhpmcounter28;    break;
            case CSR_MHPMCOUNTER29:         s_rdata = s_rdata_mhpmcounter29;    break;
            case CSR_MHPMCOUNTER30:         s_rdata = s_rdata_mhpmcounter30;    break;
            case CSR_MHPMCOUNTER31:         s_rdata = s_rdata_mhpmcounter31;    break;
            case CSR_MVENDORID:             s_rdata = s_rdata_mvendorid;        break;
            case CSR_MARCHID:               s_rdata = s_rdata_marchid;          break;
            case CSR_MIMPID:                s_rdata = s_rdata_mimpid;           break;
            case CSR_MHARTID:               s_rdata = s_rdata_mhartid;          break;
            case CSR_MCONFIGPTR:            s_rdata = s_rdata_mconfigptr;       break;
#if (OPTION_XLEN == 64)
            case CSR_VSTART:                s_rdata = s_rdata_vstart;           break;
            case CSR_VCSR:                  s_rdata = s_rdata_vcsr;             break;
            case CSR_ML2CACHECTRL:          s_rdata = s_rdata_ml2cachectrl;     break;
            case CSR_VL:                    s_rdata = s_rdata_vl;               break;
            case CSR_VTYPE:                 s_rdata = s_rdata_vtype;            break;
            case CSR_VLENB:                 s_rdata = s_rdata_vlenb;            break;
#endif //(OPTION_XLEN == 64)
#if (OPTION_XLEN == 32)
            case CSR_MSTATUSH:              s_rdata = s_rdata_mstatush;         break;
            case CSR_MENVCFGH:              s_rdata = s_rdata_menvcfgh;         break;
            case CSR_PMPCFG1:               s_rdata = s_rdata_pmpcfg1;          break;
            case CSR_PMPCFG3:               s_rdata = s_rdata_pmpcfg3;          break;
            case CSR_PMPCFG5:               s_rdata = s_rdata_pmpcfg5;          break;
            case CSR_PMPCFG7:               s_rdata = s_rdata_pmpcfg7;          break;
            case CSR_PMPCFG9:               s_rdata = s_rdata_pmpcfg9;          break;
            case CSR_PMPCFG11:              s_rdata = s_rdata_pmpcfg11;         break;
            case CSR_PMPCFG13:              s_rdata = s_rdata_pmpcfg13;         break;
            case CSR_PMPCFG15:              s_rdata = s_rdata_pmpcfg15;         break;
            case CSR_MCYCLEH:               s_rdata = s_rdata_mcycleh;          break;
            case CSR_MINSTRETH:             s_rdata = s_rdata_minstreth;        break;
            case CSR_MHPMCOUNTER3H:         s_rdata = s_rdata_mhpmcounter3h;    break;
            case CSR_MHPMCOUNTER4H:         s_rdata = s_rdata_mhpmcounter4h;    break;
            case CSR_MHPMCOUNTER5H:         s_rdata = s_rdata_mhpmcounter5h;    break;
            case CSR_MHPMCOUNTER6H:         s_rdata = s_rdata_mhpmcounter6h;    break;
            case CSR_MHPMCOUNTER7H:         s_rdata = s_rdata_mhpmcounter7h;    break;
            case CSR_MHPMCOUNTER8H:         s_rdata = s_rdata_mhpmcounter8h;    break;
            case CSR_MHPMCOUNTER9H:         s_rdata = s_rdata_mhpmcounter9h;    break;
            case CSR_MHPMCOUNTER10H:        s_rdata = s_rdata_mhpmcounter10h;   break;
            case CSR_MHPMCOUNTER11H:        s_rdata = s_rdata_mhpmcounter11h;   break;
            case CSR_MHPMCOUNTER12H:        s_rdata = s_rdata_mhpmcounter12h;   break;
            case CSR_MHPMCOUNTER13H:        s_rdata = s_rdata_mhpmcounter13h;   break;
            case CSR_MHPMCOUNTER14H:        s_rdata = s_rdata_mhpmcounter14h;   break;
            case CSR_MHPMCOUNTER15H:        s_rdata = s_rdata_mhpmcounter15h;   break;
            case CSR_MHPMCOUNTER16H:        s_rdata = s_rdata_mhpmcounter16h;   break;
            case CSR_MHPMCOUNTER17H:        s_rdata = s_rdata_mhpmcounter17h;   break;
            case CSR_MHPMCOUNTER18H:        s_rdata = s_rdata_mhpmcounter18h;   break;
            case CSR_MHPMCOUNTER19H:        s_rdata = s_rdata_mhpmcounter19h;   break;
            case CSR_MHPMCOUNTER20H:        s_rdata = s_rdata_mhpmcounter20h;   break;
            case CSR_MHPMCOUNTER21H:        s_rdata = s_rdata_mhpmcounter21h;   break;
            case CSR_MHPMCOUNTER22H:        s_rdata = s_rdata_mhpmcounter22h;   break;
            case CSR_MHPMCOUNTER23H:        s_rdata = s_rdata_mhpmcounter23h;   break;
            case CSR_MHPMCOUNTER24H:        s_rdata = s_rdata_mhpmcounter24h;   break;
            case CSR_MHPMCOUNTER25H:        s_rdata = s_rdata_mhpmcounter25h;   break;
            case CSR_MHPMCOUNTER26H:        s_rdata = s_rdata_mhpmcounter26h;   break;
            case CSR_MHPMCOUNTER27H:        s_rdata = s_rdata_mhpmcounter27h;   break;
            case CSR_MHPMCOUNTER28H:        s_rdata = s_rdata_mhpmcounter28h;   break;
            case CSR_MHPMCOUNTER29H:        s_rdata = s_rdata_mhpmcounter29h;   break;
            case CSR_MHPMCOUNTER30H:        s_rdata = s_rdata_mhpmcounter30h;   break;
            case CSR_MHPMCOUNTER31H:        s_rdata = s_rdata_mhpmcounter31h;   break;
#endif //(OPTION_XLEN == 32)
//-------- AUTOGEN END (rdata_mux) --------
	        default: break;
        }

        s_rdata_ex2 = s_rdata;
    }

    // ----------------------------------------------------------------------------------------
    // Private Function - Access Error MUX (EX2)
    // ----------------------------------------------------------------------------------------
    //Input:  s_raddr_ex2, s_read, s_write, dynamic_enables (multiple inputs)
    //Output: s_csr_read_err_ex2
    automatic void proc_access_error(void) {
        
        s_access_err = 0;
        
        //check all registers incl. shadow & cheri
        switch (s_raddr_ex2) {
//-------- AUTOGEN BEGIN (rerror_mux) --------
            case CSR_FCSR:                  s_access_err = ~s_fcsr_en;          break;
            case CSR_STVEC:                                                     break;
            case CSR_SCOUNTEREN:                                                break;
            case CSR_SENVCFG:                                                   break;
            case CSR_SSCRATCH:                                                  break;
            case CSR_SEPC:                                                      break;
            case CSR_SCAUSE:                                                    break;
            case CSR_STVAL:                                                     break;
            case CSR_SATP:                                                      break;
            case CSR_MSTATUS:                                                   break;
            case CSR_MISA:                                                      break;
            case CSR_MEDELEG:                                                   break;
            case CSR_MIDELEG:                                                   break;
            case CSR_MIE:                                                       break;
            case CSR_MTVEC:                                                     break;
            case CSR_MCOUNTEREN:                                                break;
            case CSR_MENVCFG:                                                   break;
            case CSR_MCOUNTINHIBIT:                                             break;
            case CSR_MHPMEVENT3:                                                break;
            case CSR_MHPMEVENT4:                                                break;
            case CSR_MHPMEVENT5:                                                break;
            case CSR_MHPMEVENT6:                                                break;
            case CSR_MHPMEVENT7:                                                break;
            case CSR_MHPMEVENT8:                                                break;
            case CSR_MHPMEVENT9:                                                break;
            case CSR_MHPMEVENT10:                                               break;
            case CSR_MHPMEVENT11:                                               break;
            case CSR_MHPMEVENT12:                                               break;
            case CSR_MHPMEVENT13:                                               break;
            case CSR_MHPMEVENT14:                                               break;
            case CSR_MHPMEVENT15:                                               break;
            case CSR_MHPMEVENT16:                                               break;
            case CSR_MHPMEVENT17:                                               break;
            case CSR_MHPMEVENT18:                                               break;
            case CSR_MHPMEVENT19:                                               break;
            case CSR_MHPMEVENT20:                                               break;
            case CSR_MHPMEVENT21:                                               break;
            case CSR_MHPMEVENT22:                                               break;
            case CSR_MHPMEVENT23:                                               break;
            case CSR_MHPMEVENT24:                                               break;
            case CSR_MHPMEVENT25:                                               break;
            case CSR_MHPMEVENT26:                                               break;
            case CSR_MHPMEVENT27:                                               break;
            case CSR_MHPMEVENT28:                                               break;
            case CSR_MHPMEVENT29:                                               break;
            case CSR_MHPMEVENT30:                                               break;
            case CSR_MHPMEVENT31:                                               break;
            case CSR_MSCRATCH:                                                  break;
            case CSR_MEPC:                                                      break;
            case CSR_MCAUSE:                                                    break;
            case CSR_MTVAL:                                                     break;
            case CSR_MIP:                                                       break;
            case CSR_PMPCFG0:                                                   break;
            case CSR_PMPCFG2:                                                   break;
            case CSR_PMPCFG4:                                                   break;
            case CSR_PMPCFG6:                                                   break;
            case CSR_PMPCFG8:                                                   break;
            case CSR_PMPCFG10:                                                  break;
            case CSR_PMPCFG12:                                                  break;
            case CSR_PMPCFG14:                                                  break;
            case CSR_PMPADDR0:                                                  break;
            case CSR_PMPADDR1:                                                  break;
            case CSR_PMPADDR2:                                                  break;
            case CSR_PMPADDR3:                                                  break;
            case CSR_PMPADDR4:                                                  break;
            case CSR_PMPADDR5:                                                  break;
            case CSR_PMPADDR6:                                                  break;
            case CSR_PMPADDR7:                                                  break;
            case CSR_PMPADDR8:                                                  break;
            case CSR_PMPADDR9:                                                  break;
            case CSR_PMPADDR10:                                                 break;
            case CSR_PMPADDR11:                                                 break;
            case CSR_PMPADDR12:                                                 break;
            case CSR_PMPADDR13:                                                 break;
            case CSR_PMPADDR14:                                                 break;
            case CSR_PMPADDR15:                                                 break;
            case CSR_PMPADDR16:                                                 break;
            case CSR_PMPADDR17:                                                 break;
            case CSR_PMPADDR18:                                                 break;
            case CSR_PMPADDR19:                                                 break;
            case CSR_PMPADDR20:                                                 break;
            case CSR_PMPADDR21:                                                 break;
            case CSR_PMPADDR22:                                                 break;
            case CSR_PMPADDR23:                                                 break;
            case CSR_PMPADDR24:                                                 break;
            case CSR_PMPADDR25:                                                 break;
            case CSR_PMPADDR26:                                                 break;
            case CSR_PMPADDR27:                                                 break;
            case CSR_PMPADDR28:                                                 break;
            case CSR_PMPADDR29:                                                 break;
            case CSR_PMPADDR30:                                                 break;
            case CSR_PMPADDR31:                                                 break;
            case CSR_PMPADDR32:                                                 break;
            case CSR_PMPADDR33:                                                 break;
            case CSR_PMPADDR34:                                                 break;
            case CSR_PMPADDR35:                                                 break;
            case CSR_PMPADDR36:                                                 break;
            case CSR_PMPADDR37:                                                 break;
            case CSR_PMPADDR38:                                                 break;
            case CSR_PMPADDR39:                                                 break;
            case CSR_PMPADDR40:                                                 break;
            case CSR_PMPADDR41:                                                 break;
            case CSR_PMPADDR42:                                                 break;
            case CSR_PMPADDR43:                                                 break;
            case CSR_PMPADDR44:                                                 break;
            case CSR_PMPADDR45:                                                 break;
            case CSR_PMPADDR46:                                                 break;
            case CSR_PMPADDR47:                                                 break;
            case CSR_PMPADDR48:                                                 break;
            case CSR_PMPADDR49:                                                 break;
            case CSR_PMPADDR50:                                                 break;
            case CSR_PMPADDR51:                                                 break;
            case CSR_PMPADDR52:                                                 break;
            case CSR_PMPADDR53:                                                 break;
            case CSR_PMPADDR54:                                                 break;
            case CSR_PMPADDR55:                                                 break;
            case CSR_PMPADDR56:                                                 break;
            case CSR_PMPADDR57:                                                 break;
            case CSR_PMPADDR58:                                                 break;
            case CSR_PMPADDR59:                                                 break;
            case CSR_PMPADDR60:                                                 break;
            case CSR_PMPADDR61:                                                 break;
            case CSR_PMPADDR62:                                                 break;
            case CSR_PMPADDR63:                                                 break;
            case CSR_SBPREDCTRL:                                                break;
            case CSR_TSELECT:                                                   break;
            case CSR_TDATA1:                                                    break;
            case CSR_TDATA2:                                                    break;
            case CSR_TINFO:                                                     break;
            case CSR_DCSR:                                                      break;
            case CSR_DPC:                                                       break;
            case CSR_DSCRATCH0:                                                 break;
            case CSR_DSCRATCH1:                                                 break;
            case CSR_MCFGCTRL:                                                  break;
            case CSR_MCACHESTATUS:                                              break;
            case CSR_MDCACHECTRL:                                               break;
            case CSR_MICACHECTRL:                                               break;
            case CSR_MCYCLE:                                                    break;
            case CSR_MINSTRET:                                                  break;
            case CSR_MHPMCOUNTER3:                                              break;
            case CSR_MHPMCOUNTER4:                                              break;
            case CSR_MHPMCOUNTER5:                                              break;
            case CSR_MHPMCOUNTER6:                                              break;
            case CSR_MHPMCOUNTER7:                                              break;
            case CSR_MHPMCOUNTER8:                                              break;
            case CSR_MHPMCOUNTER9:                                              break;
            case CSR_MHPMCOUNTER10:                                             break;
            case CSR_MHPMCOUNTER11:                                             break;
            case CSR_MHPMCOUNTER12:                                             break;
            case CSR_MHPMCOUNTER13:                                             break;
            case CSR_MHPMCOUNTER14:                                             break;
            case CSR_MHPMCOUNTER15:                                             break;
            case CSR_MHPMCOUNTER16:                                             break;
            case CSR_MHPMCOUNTER17:                                             break;
            case CSR_MHPMCOUNTER18:                                             break;
            case CSR_MHPMCOUNTER19:                                             break;
            case CSR_MHPMCOUNTER20:                                             break;
            case CSR_MHPMCOUNTER21:                                             break;
            case CSR_MHPMCOUNTER22:                                             break;
            case CSR_MHPMCOUNTER23:                                             break;
            case CSR_MHPMCOUNTER24:                                             break;
            case CSR_MHPMCOUNTER25:                                             break;
            case CSR_MHPMCOUNTER26:                                             break;
            case CSR_MHPMCOUNTER27:                                             break;
            case CSR_MHPMCOUNTER28:                                             break;
            case CSR_MHPMCOUNTER29:                                             break;
            case CSR_MHPMCOUNTER30:                                             break;
            case CSR_MHPMCOUNTER31:                                             break;
            case CSR_MVENDORID:                                                 break;
            case CSR_MARCHID:                                                   break;
            case CSR_MIMPID:                                                    break;
            case CSR_MHARTID:                                                   break;
            case CSR_MCONFIGPTR:                                                break;
#if (OPTION_XLEN == 64)
            case CSR_VSTART:                s_access_err = ~s_vstart_en;        break;
            case CSR_VCSR:                  s_access_err = ~s_vcsr_en;          break;
            case CSR_ML2CACHECTRL:                                              break;
            case CSR_VL:                    s_access_err = ~s_vl_en;            break;
            case CSR_VTYPE:                 s_access_err = ~s_vtype_en;         break;
            case CSR_VLENB:                 s_access_err = ~s_vlenb_en;         break;
#endif //(OPTION_XLEN == 64)
#if (OPTION_XLEN == 32)
            case CSR_MSTATUSH:                                                  break;
            case CSR_MENVCFGH:                                                  break;
            case CSR_PMPCFG1:                                                   break;
            case CSR_PMPCFG3:                                                   break;
            case CSR_PMPCFG5:                                                   break;
            case CSR_PMPCFG7:                                                   break;
            case CSR_PMPCFG9:                                                   break;
            case CSR_PMPCFG11:                                                  break;
            case CSR_PMPCFG13:                                                  break;
            case CSR_PMPCFG15:                                                  break;
            case CSR_MCYCLEH:                                                   break;
            case CSR_MINSTRETH:                                                 break;
            case CSR_MHPMCOUNTER3H:                                             break;
            case CSR_MHPMCOUNTER4H:                                             break;
            case CSR_MHPMCOUNTER5H:                                             break;
            case CSR_MHPMCOUNTER6H:                                             break;
            case CSR_MHPMCOUNTER7H:                                             break;
            case CSR_MHPMCOUNTER8H:                                             break;
            case CSR_MHPMCOUNTER9H:                                             break;
            case CSR_MHPMCOUNTER10H:                                            break;
            case CSR_MHPMCOUNTER11H:                                            break;
            case CSR_MHPMCOUNTER12H:                                            break;
            case CSR_MHPMCOUNTER13H:                                            break;
            case CSR_MHPMCOUNTER14H:                                            break;
            case CSR_MHPMCOUNTER15H:                                            break;
            case CSR_MHPMCOUNTER16H:                                            break;
            case CSR_MHPMCOUNTER17H:                                            break;
            case CSR_MHPMCOUNTER18H:                                            break;
            case CSR_MHPMCOUNTER19H:                                            break;
            case CSR_MHPMCOUNTER20H:                                            break;
            case CSR_MHPMCOUNTER21H:                                            break;
            case CSR_MHPMCOUNTER22H:                                            break;
            case CSR_MHPMCOUNTER23H:                                            break;
            case CSR_MHPMCOUNTER24H:                                            break;
            case CSR_MHPMCOUNTER25H:                                            break;
            case CSR_MHPMCOUNTER26H:                                            break;
            case CSR_MHPMCOUNTER27H:                                            break;
            case CSR_MHPMCOUNTER28H:                                            break;
            case CSR_MHPMCOUNTER29H:                                            break;
            case CSR_MHPMCOUNTER30H:                                            break;
            case CSR_MHPMCOUNTER31H:                                            break;
#endif //(OPTION_XLEN == 32)
//-------- AUTOGEN END (rerror_mux) --------
            default: s_access_err = 1; break; //error: unsupported addresses
        }
        
        //qualify with read/write indications
        s_csr_read_err_ex2  = s_access_err & s_read_ex2; //qualified with read request
    }


    // ----------------------------------------------------------------------------------------
    // Private Function - Read Only MUX (EX2)
    // ----------------------------------------------------------------------------------------
    //Input:  s_raddr_ex2
    //Output: s_csr_read_only_ex2
    automatic void proc_read_only(void) {
        
        s_read_only = 0;
        
        //check all registers incl. shadow & cheri
        switch (s_raddr_ex2) {
//-------- AUTOGEN BEGIN (ronly_mux) --------
            case CSR_FCSR:                                                      break;
            case CSR_STVEC:                                                     break;
            case CSR_SCOUNTEREN:                                                break;
            case CSR_SENVCFG:                                                   break;
            case CSR_SSCRATCH:                                                  break;
            case CSR_SEPC:                                                      break;
            case CSR_SCAUSE:                                                    break;
            case CSR_STVAL:                                                     break;
            case CSR_SATP:                                                      break;
            case CSR_MSTATUS:                                                   break;
            case CSR_MISA:                  s_read_only = 1;                    break;
            case CSR_MEDELEG:                                                   break;
            case CSR_MIDELEG:                                                   break;
            case CSR_MIE:                                                       break;
            case CSR_MTVEC:                                                     break;
            case CSR_MCOUNTEREN:                                                break;
            case CSR_MENVCFG:                                                   break;
            case CSR_MCOUNTINHIBIT:                                             break;
            case CSR_MHPMEVENT3:                                                break;
            case CSR_MHPMEVENT4:                                                break;
            case CSR_MHPMEVENT5:                                                break;
            case CSR_MHPMEVENT6:                                                break;
            case CSR_MHPMEVENT7:            s_read_only = 1;                    break;
            case CSR_MHPMEVENT8:            s_read_only = 1;                    break;
            case CSR_MHPMEVENT9:            s_read_only = 1;                    break;
            case CSR_MHPMEVENT10:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT11:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT12:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT13:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT14:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT15:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT16:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT17:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT18:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT19:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT20:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT21:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT22:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT23:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT24:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT25:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT26:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT27:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT28:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT29:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT30:           s_read_only = 1;                    break;
            case CSR_MHPMEVENT31:           s_read_only = 1;                    break;
            case CSR_MSCRATCH:                                                  break;
            case CSR_MEPC:                                                      break;
            case CSR_MCAUSE:                                                    break;
            case CSR_MTVAL:                                                     break;
            case CSR_MIP:                                                       break;
            case CSR_PMPCFG0:                                                   break;
            case CSR_PMPCFG2:                                                   break;
            case CSR_PMPCFG4:                                                   break;
            case CSR_PMPCFG6:                                                   break;
            case CSR_PMPCFG8:               s_read_only = 1;                    break;
            case CSR_PMPCFG10:              s_read_only = 1;                    break;
            case CSR_PMPCFG12:              s_read_only = 1;                    break;
            case CSR_PMPCFG14:              s_read_only = 1;                    break;
            case CSR_PMPADDR0:                                                  break;
            case CSR_PMPADDR1:                                                  break;
            case CSR_PMPADDR2:                                                  break;
            case CSR_PMPADDR3:                                                  break;
            case CSR_PMPADDR4:                                                  break;
            case CSR_PMPADDR5:                                                  break;
            case CSR_PMPADDR6:                                                  break;
            case CSR_PMPADDR7:                                                  break;
            case CSR_PMPADDR8:                                                  break;
            case CSR_PMPADDR9:                                                  break;
            case CSR_PMPADDR10:                                                 break;
            case CSR_PMPADDR11:                                                 break;
            case CSR_PMPADDR12:                                                 break;
            case CSR_PMPADDR13:                                                 break;
            case CSR_PMPADDR14:                                                 break;
            case CSR_PMPADDR15:                                                 break;
            case CSR_PMPADDR16:             s_read_only = 1;                    break;
            case CSR_PMPADDR17:             s_read_only = 1;                    break;
            case CSR_PMPADDR18:             s_read_only = 1;                    break;
            case CSR_PMPADDR19:             s_read_only = 1;                    break;
            case CSR_PMPADDR20:             s_read_only = 1;                    break;
            case CSR_PMPADDR21:             s_read_only = 1;                    break;
            case CSR_PMPADDR22:             s_read_only = 1;                    break;
            case CSR_PMPADDR23:             s_read_only = 1;                    break;
            case CSR_PMPADDR24:             s_read_only = 1;                    break;
            case CSR_PMPADDR25:             s_read_only = 1;                    break;
            case CSR_PMPADDR26:             s_read_only = 1;                    break;
            case CSR_PMPADDR27:             s_read_only = 1;                    break;
            case CSR_PMPADDR28:             s_read_only = 1;                    break;
            case CSR_PMPADDR29:             s_read_only = 1;                    break;
            case CSR_PMPADDR30:             s_read_only = 1;                    break;
            case CSR_PMPADDR31:             s_read_only = 1;                    break;
            case CSR_PMPADDR32:             s_read_only = 1;                    break;
            case CSR_PMPADDR33:             s_read_only = 1;                    break;
            case CSR_PMPADDR34:             s_read_only = 1;                    break;
            case CSR_PMPADDR35:             s_read_only = 1;                    break;
            case CSR_PMPADDR36:             s_read_only = 1;                    break;
            case CSR_PMPADDR37:             s_read_only = 1;                    break;
            case CSR_PMPADDR38:             s_read_only = 1;                    break;
            case CSR_PMPADDR39:             s_read_only = 1;                    break;
            case CSR_PMPADDR40:             s_read_only = 1;                    break;
            case CSR_PMPADDR41:             s_read_only = 1;                    break;
            case CSR_PMPADDR42:             s_read_only = 1;                    break;
            case CSR_PMPADDR43:             s_read_only = 1;                    break;
            case CSR_PMPADDR44:             s_read_only = 1;                    break;
            case CSR_PMPADDR45:             s_read_only = 1;                    break;
            case CSR_PMPADDR46:             s_read_only = 1;                    break;
            case CSR_PMPADDR47:             s_read_only = 1;                    break;
            case CSR_PMPADDR48:             s_read_only = 1;                    break;
            case CSR_PMPADDR49:             s_read_only = 1;                    break;
            case CSR_PMPADDR50:             s_read_only = 1;                    break;
            case CSR_PMPADDR51:             s_read_only = 1;                    break;
            case CSR_PMPADDR52:             s_read_only = 1;                    break;
            case CSR_PMPADDR53:             s_read_only = 1;                    break;
            case CSR_PMPADDR54:             s_read_only = 1;                    break;
            case CSR_PMPADDR55:             s_read_only = 1;                    break;
            case CSR_PMPADDR56:             s_read_only = 1;                    break;
            case CSR_PMPADDR57:             s_read_only = 1;                    break;
            case CSR_PMPADDR58:             s_read_only = 1;                    break;
            case CSR_PMPADDR59:             s_read_only = 1;                    break;
            case CSR_PMPADDR60:             s_read_only = 1;                    break;
            case CSR_PMPADDR61:             s_read_only = 1;                    break;
            case CSR_PMPADDR62:             s_read_only = 1;                    break;
            case CSR_PMPADDR63:             s_read_only = 1;                    break;
            case CSR_SBPREDCTRL:                                                break;
            case CSR_TSELECT:                                                   break;
            case CSR_TDATA1:                                                    break;
            case CSR_TDATA2:                                                    break;
            case CSR_TINFO:                                                     break;
            case CSR_DCSR:                                                      break;
            case CSR_DPC:                                                       break;
            case CSR_DSCRATCH0:                                                 break;
            case CSR_DSCRATCH1:                                                 break;
            case CSR_MCFGCTRL:                                                  break;
            case CSR_MCACHESTATUS:          s_read_only = 1;                    break;
            case CSR_MDCACHECTRL:                                               break;
            case CSR_MICACHECTRL:                                               break;
            case CSR_MCYCLE:                                                    break;
            case CSR_MINSTRET:                                                  break;
            case CSR_MHPMCOUNTER3:                                              break;
            case CSR_MHPMCOUNTER4:                                              break;
            case CSR_MHPMCOUNTER5:                                              break;
            case CSR_MHPMCOUNTER6:                                              break;
            case CSR_MHPMCOUNTER7:          s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER8:          s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER9:          s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER10:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER11:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER12:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER13:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER14:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER15:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER16:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER17:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER18:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER19:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER20:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER21:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER22:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER23:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER24:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER25:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER26:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER27:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER28:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER29:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER30:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER31:         s_read_only = 1;                    break;
            case CSR_MVENDORID:             s_read_only = 1;                    break;
            case CSR_MARCHID:               s_read_only = 1;                    break;
            case CSR_MIMPID:                s_read_only = 1;                    break;
            case CSR_MHARTID:               s_read_only = 1;                    break;
            case CSR_MCONFIGPTR:            s_read_only = 1;                    break;
#if (OPTION_XLEN == 64)
            case CSR_VSTART:                                                    break;
            case CSR_VCSR:                                                      break;
            case CSR_ML2CACHECTRL:                                              break;
            case CSR_VL:                    s_read_only = 1;                    break;
            case CSR_VTYPE:                 s_read_only = 1;                    break;
            case CSR_VLENB:                 s_read_only = 1;                    break;
#endif //(OPTION_XLEN == 64)
#if (OPTION_XLEN == 32)
            case CSR_MSTATUSH:                                                  break;
            case CSR_MENVCFGH:                                                  break;
            case CSR_PMPCFG1:                                                   break;
            case CSR_PMPCFG3:                                                   break;
            case CSR_PMPCFG5:                                                   break;
            case CSR_PMPCFG7:                                                   break;
            case CSR_PMPCFG9:               s_read_only = 1;                    break;
            case CSR_PMPCFG11:              s_read_only = 1;                    break;
            case CSR_PMPCFG13:              s_read_only = 1;                    break;
            case CSR_PMPCFG15:              s_read_only = 1;                    break;
            case CSR_MCYCLEH:                                                   break;
            case CSR_MINSTRETH:                                                 break;
            case CSR_MHPMCOUNTER3H:                                             break;
            case CSR_MHPMCOUNTER4H:                                             break;
            case CSR_MHPMCOUNTER5H:                                             break;
            case CSR_MHPMCOUNTER6H:                                             break;
            case CSR_MHPMCOUNTER7H:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER8H:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER9H:         s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER10H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER11H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER12H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER13H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER14H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER15H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER16H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER17H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER18H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER19H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER20H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER21H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER22H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER23H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER24H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER25H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER26H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER27H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER28H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER29H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER30H:        s_read_only = 1;                    break;
            case CSR_MHPMCOUNTER31H:        s_read_only = 1;                    break;
#endif //(OPTION_XLEN == 32)
//-------- AUTOGEN END (ronly_mux) --------
            default: s_read_only = 0; break;
        }

        s_csr_read_only_ex2 = s_read_only & s_read_ex2;

    } //proc_read_only()


    // ----------------------------------------------------------------------------------------
    // Private Function - Write Decoder
    // ----------------------------------------------------------------------------------------
    //Input: s_waddr_ex3
    //Output: s_swr.<reg_name>
    automatic void proc_write_decoder(void) {

        s_swr = (bit struct swr_t)(uint_<{bitsizeof(swr_t)}>)0;
        
        if (s_write_ex3) {
            switch (s_waddr_ex3) {
            //list all SW RW registers
//-------- AUTOGEN BEGIN (write_dec) --------
                case CSR_FCSR:                    s_swr.fcsr = 1;                     break;
                case CSR_STVEC:                   s_swr.stvec = 1;                    break;
                case CSR_SCOUNTEREN:              s_swr.scounteren = 1;               break;
                case CSR_SENVCFG:                 s_swr.senvcfg = 1;                  break;
                case CSR_SSCRATCH:                s_swr.sscratch = 1;                 break;
                case CSR_SEPC:                    s_swr.sepc = 1;                     break;
                case CSR_SCAUSE:                  s_swr.scause = 1;                   break;
                case CSR_STVAL:                   s_swr.stval = 1;                    break;
                case CSR_SATP:                    s_swr.satp = 1;                     break;
                case CSR_MSTATUS:                 s_swr.mstatus = 1;                  break;
                case CSR_MEDELEG:                 s_swr.medeleg = 1;                  break;
                case CSR_MIDELEG:                 s_swr.mideleg = 1;                  break;
                case CSR_MIE:                     s_swr.mie = 1;                      break;
                case CSR_MTVEC:                   s_swr.mtvec = 1;                    break;
                case CSR_MCOUNTEREN:              s_swr.mcounteren = 1;               break;
                case CSR_MENVCFG:                 s_swr.menvcfg = 1;                  break;
                case CSR_MCOUNTINHIBIT:           s_swr.mcountinhibit = 1;            break;
                case CSR_MHPMEVENT3:              s_swr.mhpmevent3 = 1;               break;
                case CSR_MHPMEVENT4:              s_swr.mhpmevent4 = 1;               break;
                case CSR_MHPMEVENT5:              s_swr.mhpmevent5 = 1;               break;
                case CSR_MHPMEVENT6:              s_swr.mhpmevent6 = 1;               break;
                case CSR_MSCRATCH:                s_swr.mscratch = 1;                 break;
                case CSR_MEPC:                    s_swr.mepc = 1;                     break;
                case CSR_MCAUSE:                  s_swr.mcause = 1;                   break;
                case CSR_MTVAL:                   s_swr.mtval = 1;                    break;
                case CSR_MIP:                     s_swr.mip = 1;                      break;
                case CSR_PMPCFG0:                 s_swr.pmpcfg0 = 1;                  break;
                case CSR_PMPCFG2:                 s_swr.pmpcfg2 = 1;                  break;
                case CSR_PMPCFG4:                 s_swr.pmpcfg4 = 1;                  break;
                case CSR_PMPCFG6:                 s_swr.pmpcfg6 = 1;                  break;
                case CSR_PMPADDR0:                s_swr.pmpaddr0 = 1;                 break;
                case CSR_PMPADDR1:                s_swr.pmpaddr1 = 1;                 break;
                case CSR_PMPADDR2:                s_swr.pmpaddr2 = 1;                 break;
                case CSR_PMPADDR3:                s_swr.pmpaddr3 = 1;                 break;
                case CSR_PMPADDR4:                s_swr.pmpaddr4 = 1;                 break;
                case CSR_PMPADDR5:                s_swr.pmpaddr5 = 1;                 break;
                case CSR_PMPADDR6:                s_swr.pmpaddr6 = 1;                 break;
                case CSR_PMPADDR7:                s_swr.pmpaddr7 = 1;                 break;
                case CSR_PMPADDR8:                s_swr.pmpaddr8 = 1;                 break;
                case CSR_PMPADDR9:                s_swr.pmpaddr9 = 1;                 break;
                case CSR_PMPADDR10:               s_swr.pmpaddr10 = 1;                break;
                case CSR_PMPADDR11:               s_swr.pmpaddr11 = 1;                break;
                case CSR_PMPADDR12:               s_swr.pmpaddr12 = 1;                break;
                case CSR_PMPADDR13:               s_swr.pmpaddr13 = 1;                break;
                case CSR_PMPADDR14:               s_swr.pmpaddr14 = 1;                break;
                case CSR_PMPADDR15:               s_swr.pmpaddr15 = 1;                break;
                case CSR_SBPREDCTRL:              s_swr.sbpredctrl = 1;               break;
                case CSR_TSELECT:                 s_swr.tselect = 1;                  break;
                case CSR_TDATA1:                  s_swr.tdata1 = 1;                   break;
                case CSR_TDATA2:                  s_swr.tdata2 = 1;                   break;
                case CSR_TINFO:                   s_swr.tinfo = 1;                    break;
                case CSR_DCSR:                    s_swr.dcsr = 1;                     break;
                case CSR_DPC:                     s_swr.dpc = 1;                      break;
                case CSR_DSCRATCH0:               s_swr.dscratch0 = 1;                break;
                case CSR_DSCRATCH1:               s_swr.dscratch1 = 1;                break;
                case CSR_MCFGCTRL:                s_swr.mcfgctrl = 1;                 break;
                case CSR_MDCACHECTRL:             s_swr.mdcachectrl = 1;              break;
                case CSR_MICACHECTRL:             s_swr.micachectrl = 1;              break;
                case CSR_MCYCLE:                  s_swr.mcycle = 1;                   break;
                case CSR_MINSTRET:                s_swr.minstret = 1;                 break;
                case CSR_MHPMCOUNTER3:            s_swr.mhpmcounter3 = 1;             break;
                case CSR_MHPMCOUNTER4:            s_swr.mhpmcounter4 = 1;             break;
                case CSR_MHPMCOUNTER5:            s_swr.mhpmcounter5 = 1;             break;
                case CSR_MHPMCOUNTER6:            s_swr.mhpmcounter6 = 1;             break;
#if (OPTION_XLEN == 64)
                case CSR_VSTART:                  s_swr.vstart = 1;                   break;
                case CSR_VCSR:                    s_swr.vcsr = 1;                     break;
                case CSR_ML2CACHECTRL:            s_swr.ml2cachectrl = 1;             break;
#endif //(OPTION_XLEN == 64)
#if (OPTION_XLEN == 32)
                case CSR_MSTATUSH:                s_swr.mstatush = 1;                 break;
                case CSR_MENVCFGH:                s_swr.menvcfgh = 1;                 break;
                case CSR_PMPCFG1:                 s_swr.pmpcfg1 = 1;                  break;
                case CSR_PMPCFG3:                 s_swr.pmpcfg3 = 1;                  break;
                case CSR_PMPCFG5:                 s_swr.pmpcfg5 = 1;                  break;
                case CSR_PMPCFG7:                 s_swr.pmpcfg7 = 1;                  break;
                case CSR_MCYCLEH:                 s_swr.mcycleh = 1;                  break;
                case CSR_MINSTRETH:               s_swr.minstreth = 1;                break;
                case CSR_MHPMCOUNTER3H:           s_swr.mhpmcounter3h = 1;            break;
                case CSR_MHPMCOUNTER4H:           s_swr.mhpmcounter4h = 1;            break;
                case CSR_MHPMCOUNTER5H:           s_swr.mhpmcounter5h = 1;            break;
                case CSR_MHPMCOUNTER6H:           s_swr.mhpmcounter6h = 1;            break;
#endif //(OPTION_XLEN == 32)
//-------- AUTOGEN END (write_dec) --------
        	    default: s_swr = (bit struct swr_t)(uint_<{bitsizeof(swr_t)}>)0;      break;
            }
        }
    }

// ********************************************************************************************
//  Function APIs (STALL, Flush, Operating Mode, DM.ddata0)
// ********************************************************************************************
    // ----------------------------------------------------------------------------------------
    // Public Function - CSR stall inputs (used by other functions, should be called first)
    // ----------------------------------------------------------------------------------------
    public always void set_stall(
                    //input
                    uint1   stall_csr_ex3
                    )
    {
        s_ex1_stall = stall_csr_ex3;
        s_ex2_stall = stall_csr_ex3;
    }

    // ----------------------------------------------------------------------------------------
    // Public Function - CSR flush inputs (used by other functions, should be called first)
    // A CSR write will be squashed in EX3 if was mispeculated in EX1 - EX3 inclusive, or 
    // on interrupts, debug halt, CHERI excepn.
    // Similarly, a PLC operation will be squashed in EX3. It is handled by 'squash_plc_ex3' in the PLC.
    // ----------------------------------------------------------------------------------------

    public always void set_flush(
                    uint1   squash_csr_write_ex3
                    )
    {
        s_ex3_flush = squash_csr_write_ex3; 
    }


    // ----------------------------------------------------------------------------------------
    // Public Function - operating mode (used by other functions, should be called first)
    // ----------------------------------------------------------------------------------------
    public always void set_operate_mode(
                    //input
                    uint3   operate_mode
                    )
    {
        s_dbg_mode = operate_mode[2];
        s_prv_mode = operate_mode[1..0];
}

    // ----------------------------------------------------------------------------------------
    // Public Function - ddata0 input
    // ----------------------------------------------------------------------------------------
    public always void set_dargs(
                    //input
                    xlen_t   ddata0)
    {
        s_ddata0 = ddata0;
    }

// ********************************************************************************************
//  Function APIs (CSR Instruction)
// ********************************************************************************************
    // ----------------------------------------------------------------------------------------
    // Public Function - drive instruction indications
    // ----------------------------------------------------------------------------------------
    // CSR instruction execution - internal output
    // -- Send read/write requests to rd_wr_access()
    // -- Send plc instruction to set_plc_instr()

    // ------------ csr rd/wr function ------------
    // Note:
    // read and write are mutually exclusive. They are driven outside m_csr_bank, based on
    //   opcode[1:0]
    //   -- CSRRW: reads the old value of the CSR, zero-extends the value to XLEN bits, then writes it to integer register rd.
    //   -- CSRRC: reads the value of the CSR, zero-extends the value to XLEN bits, and writes masked value to integer register rd.
    //   -- CSRRS: reads the value of the CSR, zero-extends the value to XLEN bits, and writes masked value to integer register rd.
    // wdata[63:0]@ex3 are generated based on rdata@ex2 and opcode[1:0] and rs1[63:0]
    //   -- CSRRW: read csr@raddr (if rd!=x0); write csr@waddr the initial value in rs1[4:0]
    //   -- CSRRC: read csr@raddr; write csr@waddr (if rs1!=X0 or uimme!=0) the rs1[4:0] value masked by rs1.
    //   -- CSRRS: read csr@raddr; write csr@waddr (if rs1!=X0 or uimme!=0) the rs1[4:0] value masked by rs1.

    public always void set_csr_instr(bool valid, struct csr_ctrl_t csr_ctrl_ex1, xlen_t rs1_val)
    {

        //wire declaration
        uint1   rs_ex3;
        uint1   rc_ex3;
        uint1   rw_ex3;
        uint1   instr_csr_ex1;
        uint1   instr_csr_i_ex1;
        uint1   instr_csrrw_ex1;
        uint1   instr_csrwo_ex1;//csrrw when rd = x0
        uint1   instr_csrrs_ex1;
        uint1   instr_csrrc_ex1;
        uint1   instr_csrro_ex1;//csrrs or csrrc when rs1 = x0
        uint1   csr_rw_vld_ex1; //csr read or write valid
        uint1   csr_r_vld_ex1;  //csr read valid
        uint1   csr_w_vld_ex1;  //csr write valid
        
        uint1   read_en_ex2;
        xlen_t  wdata_conv_ex2;

        uint1      shdw_ind_ex1;
        csr_addr_t shdw_addr_ex1;
        xlen_t     wdata_mx_ex3;
        uint1   write_en_ex3;

#ifdef OPTION_HAS_CHERI
        uint1   write_scr_xdc;
#endif

        // -------- EX1: Instruction valids --------

        //CSR instruction group
        instr_csr_ex1   =   (csr_ctrl_ex1.op == CSR_CSRRW) |
                            (csr_ctrl_ex1.op == CSR_CSRRS) |
                            (csr_ctrl_ex1.op == CSR_CSRRC) ;

        instr_csr_i_ex1 =   (csr_ctrl_ex1.op == CSR_CSRRWI) |
                            (csr_ctrl_ex1.op == CSR_CSRRSI) |
                            (csr_ctrl_ex1.op == CSR_CSRRCI) ;

        //CSR instruction valids
        instr_csrrw_ex1 = valid & ((csr_ctrl_ex1.op == CSR_CSRRW) | (csr_ctrl_ex1.op == CSR_CSRRWI)) & (csr_ctrl_ex1.opcode_rd != 0);
        instr_csrwo_ex1 = valid & ((csr_ctrl_ex1.op == CSR_CSRRW) | (csr_ctrl_ex1.op == CSR_CSRRWI)) & (csr_ctrl_ex1.opcode_rd == 0);
        instr_csrrs_ex1 = valid & ((csr_ctrl_ex1.op == CSR_CSRRS) | (csr_ctrl_ex1.op == CSR_CSRRSI)) & (csr_ctrl_ex1.opcode_rs1 != 0);
        instr_csrrc_ex1 = valid & ((csr_ctrl_ex1.op == CSR_CSRRC) | (csr_ctrl_ex1.op == CSR_CSRRCI)) & (csr_ctrl_ex1.opcode_rs1 != 0);
        instr_csrro_ex1 = valid &
                          ((csr_ctrl_ex1.op == CSR_CSRRS) | (csr_ctrl_ex1.op == CSR_CSRRSI) |
                           (csr_ctrl_ex1.op == CSR_CSRRC) | (csr_ctrl_ex1.op == CSR_CSRRCI)) &
                          (csr_ctrl_ex1.opcode_rs1 == 0);
        csr_rw_vld_ex1 = instr_csrrw_ex1 | instr_csrwo_ex1 | instr_csrrs_ex1 | instr_csrrc_ex1 | instr_csrro_ex1;
        csr_r_vld_ex1  = instr_csrrw_ex1 |                   instr_csrrs_ex1 | instr_csrrc_ex1 | instr_csrro_ex1;
        csr_w_vld_ex1  = instr_csrrw_ex1 | instr_csrwo_ex1 | instr_csrrs_ex1 | instr_csrrc_ex1;

        //PLC instruction valids
        s_instr_ebreak_ex1 = valid & (csr_ctrl_ex1.op == CSR_EBREAK);
        s_instr_ecall_ex1  = valid & (csr_ctrl_ex1.op == CSR_ECALL);
        s_instr_dret_ex1   = valid & (csr_ctrl_ex1.op == CSR_DRET);
        s_instr_mret_ex1   = valid & (csr_ctrl_ex1.op == CSR_MRET);
        s_instr_sret_ex1   = valid & (csr_ctrl_ex1.op == CSR_SRET);
        s_instr_wfi_ex1    = valid & (csr_ctrl_ex1.op == CSR_WFI);

        // -------- EX1 function call --------

        // -------- EX1-EX2 registers --------

        if (~s_ex1_stall) {
            //EX1 function call: check error for accessing debug-only registers outside debug-mode
            s_dbg_only_err_ex1 = check_dbg_only_err(csr_ctrl_ex1.opcode_csr);
            r_dbg_only_err_ex2 = s_dbg_only_err_ex1 & csr_rw_vld_ex1;

            //EX1 function call: convert raddr for shadow registers to physical address (output: s_shdw_raddr, s_shdw_read_err, s_shdw_rd_time, s_shdw_write_err)
            check_shdw_raddr(csr_ctrl_ex1.opcode_csr); //NOTE: output signals are not qualified by valid
            r_shdw_read_err_ex2 = s_shdw_read_err & csr_rw_vld_ex1; //qualified with valid csr read or write instruction
            r_shdw_write_err_ex2 = s_shdw_read_only & csr_w_vld_ex1; //qualified with valid csr write instruction

            r_instr_addr_updt_ex2       = s_shdw_raddr;//12-bit address updated for shadow register
            r_instr_opcode_csr_ex2      = csr_ctrl_ex1.opcode_csr;
            r_instr_opcode_rs1_ex2      = csr_ctrl_ex1.opcode_rs1;

            switch (csr_ctrl_ex1.op)
            {
                case CSR_CSRRW  : r_instr_opcode_func3_ex2 = 0b001; break;
                case CSR_CSRRS  : r_instr_opcode_func3_ex2 = 0b010; break;
                case CSR_CSRRC  : r_instr_opcode_func3_ex2 = 0b011; break;
                case CSR_CSRRWI : r_instr_opcode_func3_ex2 = 0b101; break;
                case CSR_CSRRSI : r_instr_opcode_func3_ex2 = 0b110; break;
                case CSR_CSRRCI : r_instr_opcode_func3_ex2 = 0b111; break;
                default         : r_instr_opcode_func3_ex2 = 0b001; break;
            }
            r_instr_opcode_rd_ex2       = csr_ctrl_ex1.opcode_rd;
            r_instr_rs1_val_ex2         = instr_csr_ex1 ? rs1_val :
                                                          (instr_csr_i_ex1 ? ((uint_<{XLEN-5}>)0 :: csr_ctrl_ex1.opcode_rs1) : r_instr_rs1_val_ex2);

            r_instr_csrro_ex2           = instr_csrro_ex1;//read-only instruction is not flushed

            r_shdw_rd_time_ex2          = s_shdw_rd_time & csr_r_vld_ex1;  //qualifed with read valids
#if (OPTION_XLEN == 32)
            r_shdw_rd_timeh_ex2         = s_shdw_rd_timeh & csr_r_vld_ex1;  //qualifed with read valids
#endif
            r_shdw_dbg_reg_ex2          = s_shdw_dbg_reg & csr_rw_vld_ex1; //qualifed with r/w valids

            //Instruction valids
            r_instr_csrrw_ex2           = instr_csrrw_ex1;
            r_instr_csrwo_ex2           = instr_csrwo_ex1;
            r_instr_csrrs_ex2           = instr_csrrs_ex1;
            r_instr_csrrc_ex2           = instr_csrrc_ex1;

            r_instr_ebreak_ex2          = s_instr_ebreak_ex1;
            r_instr_ecall_ex2           = s_instr_ecall_ex1;
            r_instr_dret_ex2            = s_instr_dret_ex1;
            r_instr_mret_ex2            = s_instr_mret_ex1;
            r_instr_sret_ex2            = s_instr_sret_ex1;
            r_instr_wfi_ex2             = s_instr_wfi_ex1;
            
        }

        // -------- EX2: read from CSR bank (indication qualified with STALL and Flush) --------
        read_en_ex2 = ~s_ex2_stall &
                      (( r_instr_csrrw_ex2 | 
                         r_instr_csrwo_ex2 |     //write-only instructions also issue read request to check exception
                         r_instr_csrrs_ex2 |
                         r_instr_csrrc_ex2) |
                       r_instr_csrro_ex2 );      //read-only instruction is not flushed

#ifdef OPTION_HAS_CHERI
        s_read_ex2     = read_en_ex2 & ~r_instr_opcode_csr_ex2[12]; //don't read SCRs
        s_scr_read_ex2 = read_en_ex2 & r_instr_opcode_csr_ex2[12];
        s_scr_raddr_ex2 = r_instr_opcode_csr_ex2;
#else
        s_read_ex2     = read_en_ex2;
#endif
        s_raddr_ex2 = r_instr_addr_updt_ex2; //only access 12-bit space

        s_read_err_ex2 = s_csr_read_err_ex2 | 
#ifdef OPTION_HAS_CHERI
                         s_scr_read_err_ex2 |
#endif
                         r_shdw_read_err_ex2 | 
                         r_dbg_only_err_ex2; //CSR bank error, or shadow error or debug_only error
        
        s_write_err_ex2 = s_csr_read_only_ex2 | r_shdw_write_err_ex2; //write to RO register

        //EX2: adjust wdata for WARL support
        //input: 12-bit address, xlen-bit wdata
        //return: xlen-bit adjusted data
        wdata_conv_ex2 = warl_wdata_conv(r_instr_addr_updt_ex2, r_instr_rs1_val_ex2);
        
        // -------- EX2-EX3 registers --------
        if (~s_ex2_stall) {
            r_instr_addr_orig_ex3       = r_instr_opcode_csr_ex2; //original address
            r_instr_addr_updt_ex3       = r_instr_addr_updt_ex2; //updated address for shadow registers
            r_instr_rs1_val_ex3         = wdata_conv_ex2; //r_instr_rs1_val_ex2;
            r_shdw_dbg_reg_ex3          = r_shdw_dbg_reg_ex2;

            //Function call: shift rdata bits for shadow registers
#ifdef OPTION_HAS_CHERI
            s_rdata_mux = r_instr_opcode_csr_ex2[12] ? 
                          s_scr_rdata_ex2 : //SCR rdata
                          s_rdata_ex2;      //CSR rdata
#endif

#if (OPTION_XLEN == 64)
            r_rdata_ex3                 = r_shdw_rd_time_ex2 ?  s_mtime[63..0] :   //read from Core input
                                                                ( r_shdw_dbg_reg_ex2 ? s_ddata0 : //read from DM output
    #ifdef OPTION_HAS_CHERI
                                                                                       shdw_rdata_shft(r_instr_opcode_csr_ex2, s_rdata_mux)); //s_rdata_mux is mux output of SCR and CSR rdata
    #else
                                                                                       shdw_rdata_shft(r_instr_opcode_csr_ex2, s_rdata_ex2)); //s_rdata_ex2 is output from rd_access()
    #endif
#else
            r_rdata_ex3                 = r_shdw_rd_time_ex2 ?  s_mtime[31..0] :
                                                                ( r_shdw_rd_timeh_ex2 ? s_mtime[63..32] :
                                                                                        (r_shdw_dbg_reg_ex2 ? s_ddata0 :
    #ifdef OPTION_HAS_CHERI                                                                                    
                                                                                        shdw_rdata_shft(r_instr_opcode_csr_ex2, s_rdata_mux)) );
    #else
                                                                                        shdw_rdata_shft(r_instr_opcode_csr_ex2, s_rdata_ex2)) );
    #endif
#endif
            r_read_ex3                  = (s_read_ex2 & ~s_read_err_ex2 & ~r_instr_csrwo_ex2) | //clear rdata valid for write-only instr and exception
#ifdef OPTION_HAS_CHERI
                                          (s_scr_read_ex2 & ~s_scr_read_err_ex2 & ~r_instr_csrwo_ex2) | 
#endif
                                          r_shdw_rd_time_ex2 | //read time
#if (OPTION_XLEN == 32)
                                          r_shdw_rd_timeh_ex2 | //read timeh
#endif
                                          r_shdw_dbg_reg_ex2;  //read ddata0

            r_csr_excep_arg_ex3         = r_instr_opcode_csr_ex2 :: r_instr_opcode_rs1_ex2 :: r_instr_opcode_func3_ex2 :: r_instr_opcode_rd_ex2 :: CSR_SYS_OP;
            r_instr_csrro_ex3           = r_instr_csrro_ex2;//read-only instruction is not flushed

            //Instruction valids
            r_instr_csrrw_ex3           = r_instr_csrrw_ex2;
            r_instr_csrwo_ex3           = r_instr_csrwo_ex2;
            r_instr_csrrs_ex3           = r_instr_csrrs_ex2;
            r_instr_csrrc_ex3           = r_instr_csrrc_ex2;
            r_csr_excep_ind_ex3         = s_read_err_ex2 | s_write_err_ex2;

        }

        // -------- EX3: write to CSR bank (indication qualified with Flush) --------
        rw_ex3 = r_instr_csrrw_ex3 | r_instr_csrwo_ex3;
        rs_ex3 = r_instr_csrrs_ex3;
        rc_ex3 = r_instr_csrrc_ex3;

        write_en_ex3 = (rw_ex3 | rs_ex3 | rc_ex3) & 
                       ~s_ex3_flush &
                       ~r_csr_excep_ind_ex3 & //no write, if exception is detected from read
                       ~r_shdw_dbg_reg_ex3; //no write if it is to dm.ddata0
#ifdef OPTION_HAS_CHERI
        write_scr_xdc =  (r_instr_addr_orig_ex3 == CSR_DDC_ADDR)  |
                         (r_instr_addr_orig_ex3 == CSR_STDC_ADDR) |
                         (r_instr_addr_orig_ex3 == CSR_MTDC_ADDR) ;
        s_scr_xdc_write_ex3 = write_en_ex3 &  write_scr_xdc & ~s_ccu_excep_ex3_i0;
        s_write_ex3         = write_en_ex3 & ~write_scr_xdc & ~s_ccu_excep_ex3_i0;
#else
        s_write_ex3 = write_en_ex3;
#endif

        s_waddr_ex3 = r_instr_addr_updt_ex3; //only access 12-bit space excluding CHERI SCRs

        switch (rw_ex3 :: rs_ex3 :: rc_ex3)
        {
            case 0b100: wdata_mx_ex3 = r_instr_rs1_val_ex3;                break; //write
            case 0b010: wdata_mx_ex3 = r_rdata_ex3 | r_instr_rs1_val_ex3;  break; //set
            case 0b001: wdata_mx_ex3 = r_rdata_ex3 & ~r_instr_rs1_val_ex3; break; //clear
            default:    wdata_mx_ex3 = r_instr_rs1_val_ex3;                break;
        }

        //shift wdata for shadow registers
        s_wdata_ex3 = shdw_wdata_shft(r_instr_addr_orig_ex3, wdata_mx_ex3);

        // -------- EX3-WB registers --------
        r_dbg_write_wb = r_shdw_dbg_reg_ex3;
        r_dbg_wdata_wb = wdata_mx_ex3;
    }

    // ----------------------------------------------------------------------------------------
    // Public Function - CSR read data output
    // ----------------------------------------------------------------------------------------
    public always void get_csr_rdata_out(
                    //output
                    uint1&  csr_rdata_vld_ex3,
                    uint64& csr_rdata_out_ex3
                    )
    {
        csr_rdata_out_ex3 = r_rdata_ex3;
        csr_rdata_vld_ex3 = r_read_ex3;
    }

// ********************************************************************************************
//  Function APIs (HW Write)
// ********************************************************************************************
    // ----------------------------------------------------------------------------------------
    // Public Function - HW direct write input
    // ----------------------------------------------------------------------------------------
    // ---- Timer input ----
    public always void set_time(uint64 mtime)
    {
        s_mtime = mtime;
    }

    // ---- HPM Counter increment ----
    public always void set_hpmcounter_incr(uint4 hpmcounter_incr_6_3)
    { //Note: if event 0 (no event) is defined, the corresponding mhpmcounter should be ROZ (controled by hpmcounter_incr_6_3 driven in dpu).
#if (OPTION_XLEN == 64)
        s_hwr.mhpmcounter6      = s_hpmcounter_6_3_en[3] & hpmcounter_incr_6_3[3];
        s_hwdata.mhpmcounter6   = r_mcountinhibit.hpm6_3[3] ? r_mhpmcounter6 : r_mhpmcounter6 + 1;
        s_hwr.mhpmcounter5      = s_hpmcounter_6_3_en[2] & hpmcounter_incr_6_3[2];
        s_hwdata.mhpmcounter5   = r_mcountinhibit.hpm6_3[2] ? r_mhpmcounter5 : r_mhpmcounter5 + 1;
        s_hwr.mhpmcounter4      = s_hpmcounter_6_3_en[1] & hpmcounter_incr_6_3[1];
        s_hwdata.mhpmcounter4   = r_mcountinhibit.hpm6_3[1] ? r_mhpmcounter4 : r_mhpmcounter4 + 1;
        s_hwr.mhpmcounter3      = s_hpmcounter_6_3_en[0] & hpmcounter_incr_6_3[0];
        s_hwdata.mhpmcounter3   = r_mcountinhibit.hpm6_3[0] ? r_mhpmcounter3 : r_mhpmcounter3 + 1;
#else
        uint64   counter6_val_64;
        uint64   counter5_val_64; 
        uint64   counter4_val_64;
        uint64   counter3_val_64;

        counter6_val_64 = r_mcountinhibit.hpm6_3[3] ? (r_mhpmcounter6h :: r_mhpmcounter6) : (r_mhpmcounter6h :: r_mhpmcounter6) + 1;
        counter5_val_64 = r_mcountinhibit.hpm6_3[2] ? (r_mhpmcounter5h :: r_mhpmcounter5) : (r_mhpmcounter5h :: r_mhpmcounter5) + 1;
        counter4_val_64 = r_mcountinhibit.hpm6_3[1] ? (r_mhpmcounter4h :: r_mhpmcounter4) : (r_mhpmcounter4h :: r_mhpmcounter4) + 1;
        counter3_val_64 = r_mcountinhibit.hpm6_3[0] ? (r_mhpmcounter3h :: r_mhpmcounter3) : (r_mhpmcounter3h :: r_mhpmcounter3) + 1;

        s_hwr.mhpmcounter6h     = s_hpmcounter_6_3_en[3] & hpmcounter_incr_6_3[3];
        s_hwdata.mhpmcounter6h  = counter6_val_64[63..32];
        s_hwr.mhpmcounter5h     = s_hpmcounter_6_3_en[2] & hpmcounter_incr_6_3[2];
        s_hwdata.mhpmcounter5h  = counter5_val_64[63..32];
        s_hwr.mhpmcounter4h     = s_hpmcounter_6_3_en[1] & hpmcounter_incr_6_3[1];
        s_hwdata.mhpmcounter4h  = counter4_val_64[63..32];
        s_hwr.mhpmcounter3h     = s_hpmcounter_6_3_en[0] & hpmcounter_incr_6_3[0];
        s_hwdata.mhpmcounter3h  = counter3_val_64[63..32];
        s_hwr.mhpmcounter6      = s_hpmcounter_6_3_en[3] & hpmcounter_incr_6_3[3];
        s_hwdata.mhpmcounter6   = counter6_val_64[31..0];
        s_hwr.mhpmcounter5      = s_hpmcounter_6_3_en[2] & hpmcounter_incr_6_3[2];
        s_hwdata.mhpmcounter5   = counter5_val_64[31..0];
        s_hwr.mhpmcounter4      = s_hpmcounter_6_3_en[1] & hpmcounter_incr_6_3[1];
        s_hwdata.mhpmcounter4   = counter4_val_64[31..0];
        s_hwr.mhpmcounter3      = s_hpmcounter_6_3_en[0] & hpmcounter_incr_6_3[0];
        s_hwdata.mhpmcounter3   = counter3_val_64[31..0];        

#endif
    }
    
    // ---- MHARTID write ----
    public always void set_mhartid(
                    //input
                    uint_<{MXLEN}> mhartid_val
                    )
    {
        s_hwr.mhartid = 1;//always enabled
        s_hwdata.mhartid = mhartid_val;
    }   
    
    // ---- MCONFIGPTR write ----
    public always void set_mconfigptr(
                    //input
                    uint_<{MXLEN}> mconfigptr_val
                    )
    {
        s_hwr.mconfigptr = 1;//always enabled
        s_hwdata.mconfigptr = mconfigptr_val;
    }

    // ---- MIP/SIP write ---- //Note: SIP is a shadow register to MIP. only implement MIP register.
    public always void set_mip(
                    //input
                    uint1   ssip,
                    uint1   msip,
                    uint1   stip,
                    uint1   mtip,
                    uint1   seip,
                    uint1   meip
                    )
    {
        if (s_dbg_mode) { //same as machine-mode
            s_top_mip_ssip_we     = r_mstatus.mie & r_mie.ssie;
            s_top_mip_ssip_val    = ssip;
            s_top_mip_msip_we     = r_mstatus.mie & r_mie.msie;
            s_top_mip_msip_val    = msip;
            s_top_mip_stip_we     = r_mstatus.mie & r_mie.stie;
            s_top_mip_stip_val    = stip;
            s_top_mip_mtip_we     = r_mstatus.mie & r_mie.mtie;
            s_top_mip_mtip_val    = mtip;
            s_top_mip_seip_we     = r_mstatus.mie & r_mie.seie;
            s_top_mip_seip_val    = seip;
            s_top_mip_meip_we     = r_mstatus.mie & r_mie.meie;
            s_top_mip_meip_val    = meip;
        } 
        else {
            switch (s_prv_mode) { //current operating mode
                case OP_MODE_S:
                    s_top_mip_ssip_we     = r_mstatus.sie & r_mie.ssie;
                    s_top_mip_ssip_val    = ssip;
                    s_top_mip_msip_we     = 0;
                    s_top_mip_msip_val    = msip;
                    s_top_mip_stip_we     = r_mstatus.sie & r_mie.stie;
                    s_top_mip_stip_val    = stip;
                    s_top_mip_mtip_we     = 0;
                    s_top_mip_mtip_val    = mtip;
                    s_top_mip_seip_we     = r_mstatus.sie & r_mie.seie;
                    s_top_mip_seip_val    = seip;
                    s_top_mip_meip_we     = 0;
                    s_top_mip_meip_val    = meip;
                    break;
                case OP_MODE_M:
                    s_top_mip_ssip_we     = r_mstatus.mie & r_mie.ssie;
                    s_top_mip_ssip_val    = ssip;
                    s_top_mip_msip_we     = r_mstatus.mie & r_mie.msie;
                    s_top_mip_msip_val    = msip;
                    s_top_mip_stip_we     = r_mstatus.mie & r_mie.stie;
                    s_top_mip_stip_val    = stip;
                    s_top_mip_mtip_we     = r_mstatus.mie & r_mie.mtie;
                    s_top_mip_mtip_val    = mtip;
                    s_top_mip_seip_we     = r_mstatus.mie & r_mie.seie;
                    s_top_mip_seip_val    = seip;
                    s_top_mip_meip_we     = r_mstatus.mie & r_mie.meie;
                    s_top_mip_meip_val    = meip;
                    break;
                default: //interrupt is diabled in User or Debug Mode
                    s_top_mip_ssip_we     = 0;
                    s_top_mip_ssip_val    = ssip;
                    s_top_mip_msip_we     = 0;
                    s_top_mip_msip_val    = msip;
                    s_top_mip_stip_we     = 0;
                    s_top_mip_stip_val    = stip;
                    s_top_mip_mtip_we     = 0;
                    s_top_mip_mtip_val    = mtip;
                    s_top_mip_seip_we     = 0;
                    s_top_mip_seip_val    = seip;
                    s_top_mip_meip_we     = 0;
                    s_top_mip_meip_val    = meip;
                    break;
            }
        }

    }

    // ---- FPU write ----
    public always void set_csr_fflags(
                    //input
                    uint1   csr_flags_we,
                    uint5   csr_fflags
                    )
    {
        //s_fcsr_fflags_we  = csr_flags_we & s_fflags_en;
        //s_fcsr_fflags_val = csr_fflags;
        s_hwr.fcsr = csr_flags_we & s_fflags_en;
        s_hwdata.fcsr = (uint_<{XLEN-5}>)0 :: csr_fflags;
    }

    // ---- IFU write ----
    public always void set_ifu_icache_status(
                    //input
                    uint1   icache_disabled,
                    uint1   icache_pref_disabled
                    )
    {
        //s_mcachestatus_icache_disabled_we       = icache_disabled;
        s_mcachestatus_icache_disabled_val      = icache_disabled;
        //s_mcachestatus_icache_pref_disabled_we  = icache_pref_disabled;
        s_mcachestatus_icache_pref_disabled_val = icache_pref_disabled;
    }

    // ---- DCU write ----
    public always void set_dcu_dcache_status(
                    //input
                    uint1   dcache_disabled,
                    uint1   dcache_pref_disabled,
                    uint1   l2cache_disabled
                    )
    {
        //s_mcachestatus_dcache_disabled_we       = dcache_disabled;
        s_mcachestatus_dcache_disabled_val      = dcache_disabled;
        //s_mcachestatus_dcache_pref_disabled_we  = dcache_pref_disabled;
        s_mcachestatus_dcache_pref_disabled_val = dcache_pref_disabled;
        //s_mcachestatus_l2cache_disabled_we      = l2cache_disabled;
        s_mcachestatus_l2cache_disabled_val     = l2cache_disabled;
    }

    // ---- PMU write ----
    public always void set_wfi_status(
                    //input
                    uint1   wfi_stop_mode
                    )
    {
        //s_mcachestatus_wfi_stop_mode_we  = wfi_stop_mode; 
        s_mcachestatus_wfi_stop_mode_val = wfi_stop_mode;
    }

// ********************************************************************************************
//  TOP (Interrupt request) & PLC Updates CSRs
// ********************************************************************************************
    
    // ----------------------------------------------------------------------------------------
    // Public Function - MIP register write MUX
    // ----------------------------------------------------------------------------------------
    //Note: both set_mip() and set_updt_csr() can update r_mip without no conflicts:
    //-- set_mip() by TOP updates r_mip if interrupt is enabled, 
    //   e.g. s_top_mip_ssip_we = r_mstatus.mie & r_mie.ssie;
    //-- set_updt_csr() by PLC should disable interrupt before updating r_mip.
    automatic void mip_sel_mux()
    {
        uint1   mip_ssip_we; 
        uint1   mip_ssip_val;
        uint1   mip_msip_we; 
        uint1   mip_msip_val;
        uint1   mip_stip_we; 
        uint1   mip_stip_val;
        uint1   mip_mtip_we; 
        uint1   mip_mtip_val;
        uint1   mip_seip_we; 
        uint1   mip_seip_val;
        uint1   mip_meip_we; 
        uint1   mip_meip_val;

        mip_ssip_we  = s_top_mip_ssip_we | s_plc_mip_ssip_we; 
        mip_ssip_val = s_top_mip_ssip_we ? s_top_mip_ssip_val : s_plc_mip_ssip_val;
        mip_msip_we  = s_top_mip_msip_we | s_plc_mip_msip_we; 
        mip_msip_val = s_top_mip_msip_we ? s_top_mip_msip_val : s_plc_mip_msip_val;
        mip_stip_we  = s_top_mip_stip_we | s_plc_mip_stip_we; 
        mip_stip_val = s_top_mip_stip_we ? s_top_mip_stip_val : s_plc_mip_stip_val;
        mip_mtip_we  = s_top_mip_mtip_we | s_plc_mip_mtip_we; 
        mip_mtip_val = s_top_mip_mtip_we ? s_top_mip_mtip_val : s_plc_mip_mtip_val;
        mip_seip_we  = s_top_mip_seip_we | s_plc_mip_seip_we; 
        mip_seip_val = s_top_mip_seip_we ? s_top_mip_seip_val : s_plc_mip_seip_val;
        mip_meip_we  = s_top_mip_meip_we | s_plc_mip_meip_we; 
        mip_meip_val = s_top_mip_meip_we ? s_top_mip_meip_val : s_plc_mip_meip_val;

        //---- mip ----
        //| 15..12 |  11  | 10 |   9  | 8 |   7  | 6 |   5  | 4 |   3  | 2 |   1  | 0 |
        //|   0    | MEIP |  0 | SEIP | 0 | MTIP | 0 | STIP | 0 | MSIP | 0 | SSIP | 0 |
        
        s_hwr.mip    = mip_ssip_we | mip_msip_we | mip_stip_we | mip_mtip_we | mip_seip_we | mip_meip_we;
        s_hwdata.mip =  (uint52)0 :: mip_meip_val :: (uint1)0 :: mip_seip_val :: (uint1)0 :: mip_mtip_val :: 
                        (uint1)0  :: mip_stip_val :: (uint1)0 :: mip_msip_val :: (uint1)0 :: mip_ssip_val :: (uint1)0;

    }
    
    // ----------------------------------------------------------------------------------------
    // Public Function - PLC Updates CSRs (TODO: Public function is only for API, take logic out)
    // ----------------------------------------------------------------------------------------
    /*
    * ---- Interrupt handler (in the PLC) ----
    * It is permitted by the various interrupt-enable and delegation bits in 
    *   Xstatus   - .MIE and .SIE fields are global interrupt enables 
    *   Xtvec     - trap-handler base address register, used to generate epc (not relevant to CSR)
    *   mideleg   - interrupt delegate register. setting a bit in mideleg will delegate the corresponding trap, 
    *               when occurring in S-mode or U-mode, to the S-mode trap handler.
    *   Xip       - 
    *   Xie       - 
    * 
    * ---- mcause ---- (NMI_MCAUSE uses 6 bits)
    * | MXLEN-1 | MXLEN-2 ... 6 | 5 ... ... 0 |
    * |   Intr  |    Reserved   | Except Code |
    * 
    * ---- mip ----
    * | 15..12 |  11  | 10 |   9  | 8 |   7  | 6 |   5  | 4 |   3  | 2 |   1  | 0 |
    * |   0    | MEIP |  0 | SEIP | 0 | MTIP | 0 | STIP | 0 | MSIP | 0 | SSIP | 0 |
    * 
    * ---- mie ----
    * | 15..12 |  11  | 10 |   9  | 8 |   7  | 6 |   5  | 4 |   3  | 2 |   1  | 0 |
    * |   0    | MEIE |  0 | SEIE | 0 | MTIE | 0 | STIE | 0 | MSIE | 0 | SSIE | 0 |
    * 
    * ---- mideleg (a bit is set to delegate the corresponding interrupt to S-mode handler) ---- 
    * | 15..12 |  11  | 10 |   9  | 8 |   7  | 6 |   5  | 4 |   3  | 2 |   1  | 0 |
    * |   0    | MEIP |  0 | SEIP | 0 | MTIP | 0 | STIP | 0 | MSIP | 0 | SSIP | 0 |
    * 
    * ---- medeleg ----
    * bit[15]: Store/AMO page fault
    * bit[14]: Reserved
    * bit[13]: Load page fault
    * bit[12]: Instruction page fault
    * bit[11]: Environment call from M-mode (ROZ). TODO: raise exception if writing 1 to this bit.
    * bit[10]: Reserved
    * bit[9]:  Environment call from S-mode
    * bit[8]:  Environment call from U-mode
    * bit[7]:  Store/AMO access fault
    * bit[6]:  Store/AMO address misaligned
    * bit[5]:  Load access fault
    * bit[4]:  Load address misaligned
    * bit[3]:  Breakpoint
    * bit[2]:  Illegal instruction
    * bit[1]:  Instruction access fault
    * bit[0]:  Instruction address misaligned
    * 
    * ---- dcsr ----
    * | 31..28   | 27..18 |    17    |    16    |    15   | 14 |    13   |   12    | 
    * | debugver |   0    | ebreakvs | ebreakvu | ebreakm | 0  | ebreaks | ebreaku |
    * |   11   |     10    |    9     |  8..6 | 5 |   4    |   3  |   2  | 1..0 |
    * | stepie | stopcount | stoptime | cause | v | mprven | nmip | step | prv  |
    */
    public always void set_updt_csr(struct plc_csr_trap_dbg_t plc_updt_csr_ex3)
    {
//        int i;
//
        uint1 ssip_clr;
        uint1 msip_clr;
        uint1 stip_clr;
        uint1 mtip_clr;
        uint1 seip_clr;
        uint1 meip_clr;
//
//        //To be moved to PLC
//        //uint64 mideleg_set_1hot; //TODO: 32-bit for L71
//        //uint16 medeleg_set_1hot;        
//        //uint1  deleg_s_mode;
//
//
        if (plc_updt_csr_ex3.cause[XLEN-1]) { //interrupt
            switch (plc_updt_csr_ex3.cause[3..0]) {
                case 1:     ssip_clr = 1;
                            //deleg_s_mode = r_mideleg[1];
                            break;
                case 3:     msip_clr = 1;
                            //deleg_s_mode = r_mideleg[3];
                            break;
                case 5:     stip_clr = 1;
                            //deleg_s_mode = r_mideleg[5];
                            break;
                case 7:     mtip_clr = 1;
                            //deleg_s_mode = r_mideleg[7];
                            break;
                case 9:     seip_clr = 1;
                            //deleg_s_mode = r_mideleg[9];
                            break;
                case 11:    meip_clr = 1;
                            //deleg_s_mode = r_mideleg[11];
                            break;
                default:    ssip_clr = 0;
                            msip_clr = 0;
                            stip_clr = 0;
                            mtip_clr = 0;
                            seip_clr = 0;
                            meip_clr = 0;
                            //deleg_s_mode = 0;
                            break;

            //To be moved to PLC
            //for(i = 0; i < 64; i++) { //NMI could use up to 64 bits
            //    mideleg_set_1hot[i] = (plc_updt_csr_ex3.cause[5..0] == i) & r_mideleg[i];
            //}
            //deleg_s_mode = |mideleg_set_1hot;

            }      
        }
        else { //exception
            ssip_clr = 0;
            msip_clr = 0;
            stip_clr = 0;
            mtip_clr = 0;
            seip_clr = 0;
            meip_clr = 0;

            //To be moved to PLC
            //for(i = 0; i < 16; i++) { //up to 16 exceptions
            //    medeleg_set_1hot[i] = (plc_updt_csr_ex3.cause[3..0] == i) & r_mideleg[i];
            //}
            //deleg_s_mode = |medeleg_set_1hot;
        }
//
//        //To be moved to PLC
//        //get trap-handler mode due to current mode and delegation settings (assuming next cycle, PLC operate_mode changes to trap_handle_mode)
//        //'trap_handle_mode' should be a PLC->CSR interface signal (live signal of operate_mode).
//        //switch (s_prv_mode) { //Traps can transition from a lower-privileged mode to a higher-privileged mode.
//        //    case OP_MODE_U: trap_handle_mode = deleg_s_mode ? OP_MODE_S : OP_MODE_M; break;
//        //    case OP_MODE_S: trap_handle_mode = deleg_s_mode ? OP_MODE_S : OP_MODE_M; break;
//        //    case OP_MODE_M: trap_handle_mode = OP_MODE_M; break;
//        //    default:        trap_handle_mode = OP_MODE_M; break;
//        //}
//
        
        //debug-mode entry
        if (plc_updt_csr_ex3.dbg_ent_vld) { //PLC to make sure dbg_ent_vld is set in debug-mode
            s_hwr.dcsr            = 1;
            s_hwdata.dcsr[1..0]   = s_prv_mode; //prv
            s_hwdata.dcsr[8..6]   = plc_updt_csr_ex3.cause; //cause
            s_hwr.dpc             = 1;
            s_hwdata.dpc          = plc_updt_csr_ex3.xpc;

        }
        //trap entry for interrupt/exception - save context
        else {
            s_hwr.dcsr            = 0;
            s_hwr.dpc             = 0;
            s_hwdata.dpc          = 0;
            s_hwdata.dcsr[1..0]   = 0; //prv
            s_hwdata.dcsr[8..6]   = 0; //cause

            if (plc_updt_csr_ex3.trap_ent_vld) {
//                //TODO: add assertion. PLC to ensure no exception request from Debug mode. "Debug Spec: Exceptions don’t update any registers."
//                //TODO: add assertion. PLC to assume interrupt is not handled in Debug mode
//                //TODO: add assertion. PLC to ensure "Delegated interrupts result in the interrupt being masked at the delegator privilege level" (Risc-V Spec).
//                //switch (trap_handle_mode) { //To be moved to PLC
                switch (plc_updt_csr_ex3.mode[1..0]) { //no trap handling from Debug-Mode
                    case 0b01: //S-Mode handler
                        s_plc_mip_ssip_we           = ssip_clr;
                        s_plc_mip_stip_we           = stip_clr;
                        s_plc_mip_seip_we           = seip_clr;
                        s_hwr.sepc                  = 1;
                        s_hwr.mstatus               = 1;
                        s_hwr.scause                = 1;
                        s_hwr.stval                 = 1;
                      
                        s_plc_mip_ssip_val          = ~ssip_clr & r_mip.ssip; //clear interrupt request
                        s_plc_mip_stip_val          = ~stip_clr & r_mip.stip; //clear interrupt request
                        s_plc_mip_seip_val          = ~seip_clr & r_mip.seip; //clear interrupt request
                        s_hwdata.sepc               = (uint_<{XLEN-ADDR_BITS}>)0 :: plc_updt_csr_ex3.xpc[ADDR_BITS-1..1];
                        s_hwdata.mstatus[1]         = 0; //sie, clear interrupt enable
                        s_hwdata.mstatus[5]         = r_mstatus.sie; //spie, save interrupt enable setting
                        s_hwdata.mstatus[8]         = s_prv_mode[0]; //spp, save privilege: 0-user, 1-supervisor
                        s_hwdata.scause[XLEN-1]     = plc_updt_csr_ex3.cause[XLEN-1];
                        s_hwdata.scause[XLEN-2..0]  = plc_updt_csr_ex3.cause[XLEN-2..0];
                        s_hwdata.stval              = plc_updt_csr_ex3.cause[XLEN-1] ? r_stval: plc_updt_csr_ex3.tval; //update tval for exception
                        break;
                    case 0b11: //M-Mode handler. By default, all traps at any privilege level are handled in machine mode
                        s_plc_mip_ssip_we           = ssip_clr;
                        s_plc_mip_msip_we           = msip_clr;
                        s_plc_mip_stip_we           = stip_clr;
                        s_plc_mip_mtip_we           = mtip_clr;
                        s_plc_mip_seip_we           = seip_clr;
                        s_plc_mip_meip_we           = meip_clr;
                        s_hwr.mepc                  = 1;
                        s_hwr.mstatus               = 1;
                        s_hwr.mcause                = 1;
                        s_hwr.mtval                 = 1;    

                        s_plc_mip_ssip_val          = ~ssip_clr & r_mip.ssip; //clear interrupt request
                        s_plc_mip_msip_val          = ~msip_clr & r_mip.msip; //clear interrupt request
                        s_plc_mip_stip_val          = ~stip_clr & r_mip.stip; //clear interrupt request
                        s_plc_mip_mtip_val          = ~mtip_clr & r_mip.mtip; //clear interrupt request
                        s_plc_mip_seip_val          = ~seip_clr & r_mip.seip; //clear interrupt request
                        s_plc_mip_meip_val          = ~meip_clr & r_mip.meip; //clear interrupt request
                        s_hwdata.mepc               = (uint_<{XLEN-ADDR_BITS}>)0 :: plc_updt_csr_ex3.xpc[ADDR_BITS-1..1] :: (uint1)0;
                        s_hwdata.mstatus[3]         = (uint1)0; //mie
                        s_hwdata.mstatus[7]         = r_mstatus.mie; //mpie
                        s_hwdata.mstatus[12..11]    = s_prv_mode[1..0]; //mpp, //save privilege: 0-user, 1-supervisor, 3-machine
                        s_hwdata.mcause[XLEN-1]     = plc_updt_csr_ex3.cause[XLEN-1];
                        s_hwdata.mcause[XLEN-2..0]  = plc_updt_csr_ex3.cause[XLEN-2..0];
                        s_hwdata.mtval              = plc_updt_csr_ex3.cause[XLEN-1] ? r_mtval: plc_updt_csr_ex3.tval;
                        break;
                    default:
                        break;
                }
            }

            //trap return for interrupt/exception/debug - restore context
            else if (plc_updt_csr_ex3.xret_vld & ~s_dbg_mode) { //SRET or MRET
                switch (s_prv_mode) { //s_prv_mode(current mode) = plc_csr_trap_dbg_t.mode[1..0](trap handling mode)
                    case OP_MODE_S://SRET
                        s_hwr.mstatus           = 1;
                        s_hwdata.mstatus[1]     = r_mstatus.spie; //sie
                        s_hwdata.mstatus[5]     = 0; //spie
                        s_hwdata.mstatus[8]     = 0; //spp
                        //ret_operate_mode    = s_prv_mode[2..1] :: r_mstatus.spp;
                        //ret_pc              = r_sepc.epc :: (uint1)0;
                        break;
                    case OP_MODE_M://MRET
                        s_hwr.mstatus            = 1;                   
                        s_hwdata.mstatus[3]      = r_mstatus.mpie; //mie
                        s_hwdata.mstatus[7]      = 0; //mpie
                        s_hwdata.mstatus[12..11] = 0; //mpp
                        //ret_operate_mode    = s_prv_mode[2] :: r_mstatus.mpp[1..0];
                        //ret_pc              = r_mepc.epc :: (uint1)0;
                        break;
                    default:
                        break;
                }
            }
            else if (plc_updt_csr_ex3.xret_vld & s_dbg_mode) { //DRET: no CSR write execution
                //ret_operate_mode    = s_prv_mode[2] :: r_dcsr.prv;
                //ret_pc              = r_dpc.dpc :: (uint1)0;
            }
            else { //no update requests
                s_plc_mip_ssip_we           = 0;
                s_plc_mip_msip_we           = 0;
                s_plc_mip_stip_we           = 0;
                s_plc_mip_mtip_we           = 0;
                s_plc_mip_seip_we           = 0;
                s_plc_mip_meip_we           = 0;

                s_hwr.sepc                  = 0;
                s_hwr.mstatus               = 0;
                s_hwr.scause                = 0;
                s_hwr.stval                 = 0;
                s_hwr.mepc                  = 0;
                s_hwr.mcause                = 0;
                s_hwr.mtval                 = 0;

                s_plc_mip_ssip_val          = 0;
                s_plc_mip_msip_val          = 0;
                s_plc_mip_stip_val          = 0;
                s_plc_mip_mtip_val          = 0;
                s_plc_mip_seip_val          = 0;
                s_plc_mip_meip_val          = 0;

                s_hwdata.sepc               = 0;
                s_hwdata.mepc               = 0;
                s_hwdata.mstatus            = 0;
                s_hwdata.scause             = 0;
                s_hwdata.mcause             = 0;
                s_hwdata.stval              = 0;
                s_hwdata.mtval              = 0;

            }
        }
    }

// ********************************************************************************************
//  CSR counters
// ********************************************************************************************
    // ----------------------------------------------------------------------------------------
    // Public Function - CSR counters
    // ----------------------------------------------------------------------------------------
    public always void set_instr_retr(
                    //input
                    uint2   plc_instr_retr_ex3)
    {
#if (OPTION_XLEN == 64)
        switch (plc_instr_retr_ex3) {
            case 0b00: 
                s_hwdata.minstret = r_minstret;
                break;
            case 0b01:
                s_hwdata.minstret = r_mcountinhibit.ir ? r_minstret : r_minstret + 1;
                break;
            case 0b10:
                s_hwdata.minstret = r_mcountinhibit.ir ? r_minstret : r_minstret + 1;
                break;
            case 0b11:
                s_hwdata.minstret = r_mcountinhibit.ir ? r_minstret : r_minstret + 2;
                break;           
        }
        s_hwr.minstret = |plc_instr_retr_ex3 & s_instret_en;
#else
        uint64  instret_val_64;
        switch (plc_instr_retr_ex3) {
            case 0b00: 
                instret_val_64 = r_minstreth :: r_minstret;
                break;
            case 0b01:
                instret_val_64 = r_mcountinhibit.ir ? (r_minstreth :: r_minstret) : (r_minstreth :: r_minstret) + 1;
                break;
            case 0b10:
                instret_val_64 = r_mcountinhibit.ir ? (r_minstreth :: r_minstret) : (r_minstreth :: r_minstret) + 1;
                break;
            case 0b11:
                instret_val_64 = r_mcountinhibit.ir ? (r_minstreth :: r_minstret) : (r_minstreth :: r_minstret) + 2;
                break;           
        }        
        s_hwr.minstreth    = |plc_instr_retr_ex3 & s_instret_en;
        s_hwr.minstret     = |plc_instr_retr_ex3 & s_instret_en;
        s_hwdata.minstreth = instret_val_64[63..32];
        s_hwdata.minstret  = instret_val_64[31..0];
#endif

    }

    // ----------------------------------------------------------------------------------------
    // Automatic Function - CSR cycle counters
    // ----------------------------------------------------------------------------------------
//TODO: connect to an additional clk_in pin if the default clock for counter increment can be gated
//    public always void set_clk(uint1 clk_in)
//    {
//        s_hwr.mcycle  = clk_in;
//        s_hwdata.mcycle = r_mcycle + 1;
//    }

    automatic void cycle_cnt()
    {
#if (OPTION_XLEN == 64)
        s_hwr.mcycle  = s_cycle_en;
        s_hwdata.mcycle = r_mcountinhibit.cy ? r_mcycle : r_mcycle + 1;
#else
        uint64 cycle_val_64;
        
        s_hwr.mcycleh   = s_cycle_en;
        s_hwr.mcycle    = s_cycle_en;

        cycle_val_64    = r_mcountinhibit.cy ? (r_mcycleh :: r_mcycle) : (r_mcycleh :: r_mcycle) + 1;
        s_hwr.mcycleh   = cycle_val_64[63..32];
        s_hwdata.mcycle = cycle_val_64[31..0];
#endif

    }

// ********************************************************************************************
//  Triggers
// ********************************************************************************************
    // ----------------------------------------------------------------------------------------
    // Private Function - Trigger implementation
    // ----------------------------------------------------------------------------------------
//Note: the following code with macroprocessor doesn't work for now.
//It also relates to "#define TRIGGERS    4u" or "#define TRIGGERS    4"
//Bug: https://codasip.atlassian.net/browse/STUDIO-6789
//   automatic void trigger_comp()
//   {
//       int i;
//
//       uint_<{TRIGGERS}> i0_pc_match_x;
//       uint_<{TRIGGERS}> i1_pc_match_x;
//       uint_<{TRIGGERS}> ls_match_x;
//
//       uint_<{TRIGGERS}> mcontrol6_typ6;
//       uint_<{TRIGGERS}> mode_enable;
//
//       //tdata1 format: 
//       // XLEN-1..XLEN-4 | XLEN-5 | XLEN-5..XLEN-11 | XLEN-12..23| 22..21 | 20 | 19     | 18     | 17..16 | 15..12 | 11    | 10..7 | 6 | 5 | 4 | 3 | 2       | 1     | 0
//       //      type      | dmode  |     maskmax     |      0     | sizehi | hit| select | timing | sizelo | action | chain | match | m | 0 | s | u | execute | store | load 
//
//       $$for(i = 0; i < TRIGGERS; i++)
//           mode_enable[$$(i)] = (r_tdata1[$$(i)][6] & (s_op_mode == 0b11)) | //m is set for m-mode
//                                (r_tdata1[$$(i)][4] & (s_op_mode == 0b01)) | //s is set for s-mode
//                                (r_tdata1[$$(i)][3] & (s_op_mode == 0b00)) ; //u is set for u-mode
//           
//           mcontrol6_typ6[$$(i)] =  //r_tdata1[i][63..60] == (uint4)6;
//                                   r_tdata1[$$(i)][(XLEN-1)..(XLEN-4)] == (uint4)6;
//           
//           i0_pc_match_x[$$(i)] =  (r_tselect == (xlen_t)$$(i)) &  //trigger_i is selected
//                                   mode_enable[$$(i)] &                            //in the corrent mode
//                                   mcontrol6_typ6[$$(i)] &                          //type = montrol6
//                                   r_tdata1[$$(i)][2] &                   //execute is set
//                                   r_tdata2[$$(i)] == s_i0_pc;
//
//           i1_pc_match_x[$$(i)] =  (r_tselect == (xlen_t)$$(i)) &  //trigger_i is selected
//                                   mode_enable[$$(i)] &                            //in the corrent mode
//                                   mcontrol6_typ6[$$(i)] &                          //type = montrol6
//                                   r_tdata1[$$(i)][2] &                   //execute is set
//                                   r_tdata2[$$(i)] == s_i1_pc;
//
//           ls_match_x[$$(i)]    =  (r_tselect == (xlen_t)$$(i)) &  //trigger_i is selected
//                                   mode_enable[$$(i)] &                            //in the corrent mode
//                                   mcontrol6_typ6[$$(i)] &                          //type = montrol6
//                                   (s_is_store ? r_tdata1[$$(i)][1] & r_tdata2[$$(i)] == s_ls_addr : //store is set width address match
//                                                 r_tdata1[$$(i)][0] & r_tdata2[$$(i)] == s_ls_addr); //load is set with address match
//       $$endfor()
//
//       //get match indications
//       s_i0_pc_match = |i0_pc_match_x;
//       s_i1_pc_match = |i1_pc_match_x;
//       s_ls_match    = |ls_match_x;
//
//   }

   automatic void trigger_comp()
    {
        int i;
       
        uint1 i0_pc_match_x[TRIGGERS];
        uint1 i1_pc_match_x[TRIGGERS];
        uint1 ls_match_x[TRIGGERS];
        uint1 i0_ls_match_x[TRIGGERS];
        uint1 i1_ls_match_x[TRIGGERS];
        uint1 match_x_act_dbg[TRIGGERS];
        uint1 match_x_act_excpt[TRIGGERS];
        uint1 match_x_act_trace[TRIGGERS];
        //uint1 match_x[TRIGGERS];
        uint1 match_x_typ[TRIGGERS];
        uint1 match_x_i0[TRIGGERS];
        uint1 match_x_i1[TRIGGERS];
        uint1 match_x_i0_dbg[TRIGGERS];
        uint1 match_x_i0_excpt[TRIGGERS];
        uint1 match_x_i0_trace[TRIGGERS];
        uint1 match_x_i1_dbg[TRIGGERS];
        uint1 match_x_i1_excpt[TRIGGERS];
        uint1 match_x_i1_trace[TRIGGERS]; 

        uint1 mcontrol6_typ6[TRIGGERS];
        uint4 mcontrol6_sz0[TRIGGERS];
        uint3 mcontrol6_act[TRIGGERS];
        uint1 mode_enable[TRIGGERS];

        uint_<{TRIGGERS}> match_vec_i0_dbg;
        uint_<{TRIGGERS}> match_vec_i0_excpt;
        uint_<{TRIGGERS}> match_vec_i0_trace;
        uint_<{TRIGGERS}> match_vec_i1_dbg;
        uint_<{TRIGGERS}> match_vec_i1_excpt;
        uint_<{TRIGGERS}> match_vec_i1_trace;
        uint_<{TRIGGERS}> first_match_vec_i0_dbg;
        uint_<{TRIGGERS}> first_match_vec_i0_excpt;
        uint_<{TRIGGERS}> first_match_vec_i0_trace;
        uint_<{TRIGGERS}> first_match_vec_i1_dbg;
        uint_<{TRIGGERS}> first_match_vec_i1_excpt;
        uint_<{TRIGGERS}> first_match_vec_i1_trace;
        uint3 trigger_action_i0;
        uint3 trigger_action_i1;
        uint1 trigger_type_i0;
        uint1 trigger_type_i1;
        uint_<{TRIGGERS}> trigger_hit_i0;
        uint_<{TRIGGERS}> trigger_hit_i1;
        uint_<{TRIGGERS}> trigger_hit; 

        //tdata1 (mcontrol6) format: 
        // XLEN-1..XLEN-4 | XLEN-5 | XLEN-6..25 | 24 | 23 | 22  |   21   |   20   | 19..16 | 15..12 | 11    | 10..7 | 6 | 5 | 4 | 3 | 2       | 1     | 0
        //      type      | dmode  |      0     | vs | vu | hit | select | timing |  size  | action | chain | match | m | 0 | s | u | execute | store | load 
        //size: data size of memory accesses. e.g. load 64bit data from addr0: load addresses are addr0-7 
        //size = 0 (any). Note: LS width is not checked. Only compare load/store start address.
        //action = 0(exception), 1(debug), 2(trace on), 3(trace off), 4(trace notify)
        
        for(i = 0; i < TRIGGERS; i++) {
            mode_enable[i] = ~s_dbg_mode & //Triggers don't fire while in debug mode
                             ((r_tdata1[i][6] & (s_op_mode == 0b11)) |  //m is set for m-mode
                              (r_tdata1[i][4] & (s_op_mode == 0b01)) |  //s is set for s-mode
                              (r_tdata1[i][3] & (s_op_mode == 0b00))) ; //u is set for u-mode
            
            mcontrol6_typ6[i] = (r_tdata1[i][(XLEN-1)..(XLEN-4)] == (uint4)6);
            mcontrol6_sz0[i]  = (r_tdata1[i][19..16] == 0); //only support 0

            //address comparison
            i0_pc_match_x[i] =  (r_tselect.idx == (uint2)i) &           //trigger_i is selected
                                mode_enable[i] &                                //in the corrent mode
                                mcontrol6_typ6[i] &                             //type = montrol6
                                mcontrol6_sz0[i] &                              //size = 0
                                r_tdata1[i][2] &                     //execute is set
                                r_tdata2[i] == s_i0_pc_ex1 &
                                s_i0_vld_ex1;                                   //qualified with i0 valid

            i1_pc_match_x[i] =  (r_tselect.idx == (uint2)i) &           //trigger_i is selected
                                mode_enable[i] &                                //in the corrent mode
                                mcontrol6_typ6[i] &                             //type = montrol6
                                mcontrol6_sz0[i] &                              //size = 0
                                r_tdata1[i][2] &                     //execute is set
                                r_tdata2[i] == s_i1_pc_ex1 &
                                s_i1_vld_ex1;                                   //qualified with i1 valid

            ls_match_x[i]    =  (r_tselect.idx == (uint2)i) &           //trigger_i is selected
                                mode_enable[i] &                                //in the corrent mode
                                mcontrol6_typ6[i] &                             //type = montrol6
                                mcontrol6_sz0[i] &                              //size = 0
                                (s_is_store_ex1 ? r_tdata1[i][1] & r_tdata2[i] == s_ls_addr_ex1 :  //store is set width address match
                                                  r_tdata1[i][0] & r_tdata2[i] == s_ls_addr_ex1) & //load is set with address match
                                s_ls_vld_ex1;                                   //qualified with ls valid

            i0_ls_match_x[i] =  ls_match_x[i] & ~s_is_i1_ex1;
            i1_ls_match_x[i] =  ls_match_x[i] & s_is_i1_ex1;
            
            //match indication (match_x_i0 and match_x_i1 are mutually exclusive)
            match_x_i0[i]    =  i0_pc_match_x[i] | i0_ls_match_x[i];
            match_x_i1[i]    =  (i1_pc_match_x[i] | i1_ls_match_x[i]) & ~match_x_i0[i]; //set only if there is no i0 match

            //match action
            mcontrol6_act[i]     =  r_tdata1[i][14..12];
            match_x_act_dbg[i]   =  mcontrol6_act[i] == (uint3)1;  
            match_x_act_excpt[i] =  mcontrol6_act[i] == (uint3)0;
            match_x_act_trace[i] =  mcontrol6_act[i] == (uint3)2 |
                                    mcontrol6_act[i] == (uint3)3 |
                                    mcontrol6_act[i] == (uint3)4 ;

            //generate trigger_x output
            match_x_i0_dbg[i]   = match_x_i0[i] & match_x_act_dbg[i];
            match_x_i0_excpt[i] = match_x_i0[i] & match_x_act_excpt[i];
            match_x_i0_trace[i] = match_x_i0[i] & match_x_act_trace[i];
            match_x_i1_dbg[i]   = match_x_i1[i] & match_x_act_dbg[i];
            match_x_i1_excpt[i] = match_x_i1[i] & match_x_act_excpt[i];
            match_x_i1_trace[i] = match_x_i1[i] & match_x_act_trace[i];            


            //determine trigger_x type of match (0:pc, 1:data), in case multiple matches are detected within one trigger: i0>i1, pc>ls_addr
            //TODO: rewrite with for-loop
            switch (i0_pc_match_x[i] :: i0_ls_match_x[i] :: i1_pc_match_x[i] :: i1_ls_match_x[i]) {
                case 0b0001: match_x_typ[i] = 1; break; //i1_ls_match_x
                case 0b0010: match_x_typ[i] = 0; break; //i1_pc_match_x
                case 0b0011: match_x_typ[i] = 0; break; //i1_pc_match_x
                case 0b0100: match_x_typ[i] = 1; break; //i0_ls_match_x
                case 0b0101: match_x_typ[i] = 1; break; //i0_ls_match_x
                case 0b0110: match_x_typ[i] = 1; break; //i0_ls_match_x
                case 0b0111: match_x_typ[i] = 1; break; //i0_ls_match_x
                case 0b1000: match_x_typ[i] = 0; break; //i0_pc_match_x
                case 0b1001: match_x_typ[i] = 0; break; //i0_pc_match_x
                case 0b1010: match_x_typ[i] = 0; break; //i0_pc_match_x
                case 0b1011: match_x_typ[i] = 0; break; //i0_pc_match_x
                case 0b1100: match_x_typ[i] = 0; break; //i0_pc_match_x
                case 0b1101: match_x_typ[i] = 0; break; //i0_pc_match_x
                case 0b1110: match_x_typ[i] = 0; break; //i0_pc_match_x
                case 0b1111: match_x_typ[i] = 0; break; //i0_pc_match_x
                default:     match_x_typ[i] = 0; break; //case 0b0000: no match
            }

        }

        //Select match output from 4 triggers (not parameterised) - get trigger index
        //i0 > i1, debug>exception>trace, trigger0 > trigger1 > trigger2 > trigger3

        //convert array to vector
        match_vec_i0_dbg   = (bit uint_<{TRIGGERS}>)match_x_i0_dbg;
        match_vec_i0_excpt = (bit uint_<{TRIGGERS}>)match_x_i0_excpt;
        match_vec_i0_trace = (bit uint_<{TRIGGERS}>)match_x_i0_trace;
        match_vec_i1_dbg   = (bit uint_<{TRIGGERS}>)match_x_i1_dbg;
        match_vec_i1_excpt = (bit uint_<{TRIGGERS}>)match_x_i1_excpt;
        match_vec_i1_trace = (bit uint_<{TRIGGERS}>)match_x_i1_trace;

        //output to FWD
        s_trigger_flush_i0 = |match_vec_i0_dbg |
                             |match_vec_i0_excpt |
                             |match_vec_i0_trace;
        s_trigger_flush_i1 = |match_vec_i1_dbg |
                             |match_vec_i1_excpt |
                             |match_vec_i1_trace;

       
        //Get first match (1-hot) with smallest trigger number
        first_match_vec_i0_dbg   = (~match_vec_i0_dbg   + (uint_<{TRIGGERS}>)1) & match_vec_i0_dbg  ;
        first_match_vec_i0_excpt = (~match_vec_i0_excpt + (uint_<{TRIGGERS}>)1) & match_vec_i0_excpt;
        first_match_vec_i0_trace = (~match_vec_i0_trace + (uint_<{TRIGGERS}>)1) & match_vec_i0_trace;
        first_match_vec_i1_dbg   = (~match_vec_i1_dbg   + (uint_<{TRIGGERS}>)1) & match_vec_i1_dbg  ;
        first_match_vec_i1_excpt = (~match_vec_i1_excpt + (uint_<{TRIGGERS}>)1) & match_vec_i1_excpt;
        first_match_vec_i1_trace = (~match_vec_i1_trace + (uint_<{TRIGGERS}>)1) & match_vec_i1_trace;

        trigger_type_i0 = (uint1)0;
        trigger_type_i1 = (uint1)0;
        trigger_action_i0 = (uint3)0;
        trigger_action_i1 = (uint3)0;

        //Output trigger action & type
        if (|match_vec_i0_dbg) {
            for(i = 0; i < TRIGGERS; i++) {
                if (first_match_vec_i0_dbg[(uint_<{clog2(TRIGGERS)}>)i]) { //cast i to suppress warnings (out-of-range, negative value)
                    trigger_action_i0 = mcontrol6_act[i];
                    trigger_type_i0   = match_x_typ[i];
                }
            }
            trigger_hit_i0 = first_match_vec_i0_dbg;
        }
        /* Alternative solution for warnings on i
        if (|match_vec_i0_dbg) {
            for(i = 0; i < TRIGGERS; i++) {
                uint_<{clog2(TRIGGERS)}> idx;
                idx = i;
                if (first_match_vec_i0_dbg[idx]) {
                    trigger_action_i0 = mcontrol6_act[idx];
                    trigger_type_i0   = match_x_typ[idx];
                }
            }
            trigger_hit_i0 = first_match_vec_i0_dbg;
        }
        */  
        else if (|match_vec_i0_excpt) {
            for(i = 0; i < TRIGGERS; i++) {
                if (first_match_vec_i0_excpt[(uint_<{clog2(TRIGGERS)}>)i]) {
                    trigger_action_i0 = mcontrol6_act[i];
                    trigger_type_i0   = match_x_typ[i];
                }
            }
            trigger_hit_i0 = first_match_vec_i0_excpt;
        }
        else if (|match_vec_i0_trace) {
            for(i = 0; i < TRIGGERS; i++) {
                if (first_match_vec_i0_trace[(uint_<{clog2(TRIGGERS)}>)i]) {
                    trigger_action_i0 = mcontrol6_act[i];
                    trigger_type_i0   = match_x_typ[i];
                }
            }
            trigger_hit_i0 = first_match_vec_i0_trace; 
        }               
        else {
            trigger_action_i0 = (uint3)0;
            trigger_type_i0 = (uint1)0;
            trigger_hit_i0 = (uint_<{TRIGGERS}>)0;
        }


        if (|match_vec_i1_dbg) {
            for(i = 0; i < TRIGGERS; i++) {
                if (first_match_vec_i1_dbg[(uint_<{clog2(TRIGGERS)}>)i]) {
                    trigger_action_i1 = mcontrol6_act[i];
                    trigger_type_i1   = match_x_typ[i];
                }
            }
            trigger_hit_i1 = first_match_vec_i1_dbg;
        } 
        else if (|match_vec_i1_excpt) {
            for(i = 0; i < TRIGGERS; i++) {
                if (first_match_vec_i1_excpt[(uint_<{clog2(TRIGGERS)}>)i]) {
                    trigger_action_i1 = mcontrol6_act[i];
                    trigger_type_i1   = match_x_typ[i];
                }
            }
            trigger_hit_i1 = first_match_vec_i1_excpt;
        }
        else if (|match_vec_i1_trace) {
            for(i = 0; i < TRIGGERS; i++) {
                if (first_match_vec_i1_trace[(uint_<{clog2(TRIGGERS)}>)i]) {
                    trigger_action_i1 = mcontrol6_act[i];
                    trigger_type_i1   = match_x_typ[i];
                }
            }
            trigger_hit_i1 = first_match_vec_i0_trace; 
        }               
        else {
            trigger_action_i1 = (uint3)0;
            trigger_type_i1 = (uint1)0;
            trigger_hit_i1 = (uint_<{TRIGGERS}>)0;
        }

        //output to PLC
        s_trigger_match  = s_trigger_flush_i0 | s_trigger_flush_i1;
        s_trigger_type   = s_trigger_flush_i0 ? trigger_type_i0 : trigger_type_i1; //select from match_x_typ
        s_trigger_is_i1  = s_trigger_flush_i1;
        s_trigger_action = s_trigger_flush_i0 ? trigger_action_i0 : trigger_action_i1; //select from mcontrol6_act
        
        //Set 'hit' index (mcontrol.hit should be set by PLC in EX3 when instruction is not speculative and trigger is executed)
        trigger_hit = trigger_hit_i0 | trigger_hit_i1;
        for(i = 0; i < TRIGGERS; i++) {
            if (trigger_hit[(uint_<{clog2(TRIGGERS)}>)i] == 1) {
                s_trigger_idx = i;
            }
        }
    }

    automatic void trigger_out_register() {
        if (~s_ex1_stall) { //trigger indications are not flushed in EX1/EX2. If flush is needed, it is cancelled in EX3 by instruction valid.
            r_trigger_match_ex2  = s_trigger_match;
            r_trigger_type_ex2   = s_trigger_type;
            r_trigger_is_i1_ex2  = s_trigger_is_i1;
            r_trigger_action_ex2 = s_trigger_action;
            r_trigger_idx_ex2    = s_trigger_idx;
        }

        if (~s_ex2_stall) {
            r_trigger_idx_ex3    = r_trigger_idx_ex2;
        }
    }


    // ----------------------------------------------------------------------------------------
    // Private Function - Set trigger 'hit' bit in tdata1 if trigger fires
    // ----------------------------------------------------------------------------------------
    //tdata1 (montrol6) format:
    //| XLEN-1..XLEN-4 | XLEN-5 | XLEN-6..25 | 24 | 23 | 22  |   21   |   20   | 19..16 | 15..12 |  11   | 10..7 | 6 | 5 | 4 | 3 |    2    |   1   |  0   |
    //|      type      | demode |      0     | vs | vu | hit | select | timing |  size  | action | chain | match | m | 0 | s | u | execute | store | load |  

    automatic void trigger_set_hit() //'hit' is set by HW and cleared by SW
    {
        s_hwr.tdata1    = s_set_hit;
        s_hwdata.tdata1 = r_tdata1[r_trigger_idx_ex3][XLEN-1..23] :: (uint1)1 :: r_tdata1[r_trigger_idx_ex3][21..0];
        s_hwidx_tdata1  = r_trigger_idx_ex3;
    }

    // ----------------------------------------------------------------------------------------
    // Public Function - Trigger Inputs/Outputs
    // ----------------------------------------------------------------------------------------
    /**
     * dci_trigger_match_iX: DCI (PC) trigger match (triggers located in CSR)
     */
    //public always bool dci_trigger_match_i0(uint64 addr)
    //{
    //    s_i0_pc = addr;         
    //    return s_i0_pc_match;
    //}
    //public always bool dci_trigger_match_i1(uint64 addr)
    //{
    //    s_i1_pc = addr;         
    //    return s_i1_pc_match;
    //}
    /**
     * dcu_trigger_match: DCU (LSU addr) trigger match (triggers located in CSR)
     */
    //public always bool dcu_trigger_match(uint64 addr, bool is_store)
    //{
    //    s_ls_addr = addr;
    //    s_is_store = is_store;
    //    return s_ls_match;
    //}
    public always void set_pc_trigger_i0_ex1(uint64 addr, uint1 valid)
    {
        s_i0_pc_ex1  = addr;
        s_i0_vld_ex1 = valid;

    }
    public always void set_pc_trigger_i1_ex1(uint64 addr, uint1 valid)
    {
        s_i1_pc_ex1  = addr;
        s_i1_vld_ex1 = valid;
    }
    public always void set_ls_trigger_ex1(uint64 addr, uint1 valid, uint1 is_i1, uint1 is_store)
    {
        s_ls_addr_ex1  = addr;
        s_ls_vld_ex1   = valid;
        s_is_i1_ex1    = is_i1;
        s_is_store_ex1 = is_store;
    }
    public always void get_trigger_flush_i0_ex1(uint1& flush_i0)
    {
        flush_i0 = s_trigger_flush_i0;
    }
    public always void get_trigger_flush_i1_ex1(uint1& flush_i1)
    {
        flush_i1 = s_trigger_flush_i1;
    }
    public always void get_trigger_match_ex2(uint1& match, uint1& typ, uint1& is_i1, uint3& act)
    {
        match  = r_trigger_match_ex2; 
        typ    = r_trigger_type_ex2;
        is_i1  = r_trigger_is_i1_ex2;
        act    = r_trigger_action_ex2; 
    }
    public always void set_trigger_hit_ex3(uint1 set_hit)
    {
        s_set_hit = set_hit;
    }


// ********************************************************************************************
//  CSR Exception
// ********************************************************************************************
    // ----------------------------------------------------------------------------------------
    // Public Function - CSR exception output
    // ----------------------------------------------------------------------------------------
    //TODO: check with Arch if m_cycle_en, s_m_time_en, m_instret_en, mpmcounter_*_en should be implemented
    public always void get_csr_excep(
                    //output
                    uint1&  csr_excep_ind_ex3,
                    uint32& csr_excep_arg_ex3
                    )
    {
        //internal wire
        uint32  csr_excep_ind_ex2;
        
        //generate register enables for m_csr_bank and shadow registers
        if (s_dbg_mode) { 
            //same as machine-mode
            s_fflags_en = (r_mstatus.fs == 1);
            s_frm_en    = (r_mstatus.fs == 1);
            s_fcsr_en   = (r_mstatus.fs == 1);
#if (OPTION_XLEN == 64)
            s_vstart_en = (r_mstatus.vs == 1) & (r_misa.v == 1);
            s_vxsat_en  = (r_mstatus.vs == 1) & (r_misa.v == 1);
            s_vxrm_en   = (r_mstatus.vs == 1) & (r_misa.v == 1);
            s_vcsr_en   = (r_mstatus.vs == 1) & (r_misa.v == 1);
            s_vl_en     = (r_mstatus.vs == 1) & (r_misa.v == 1);
            s_vtype_en  = (r_mstatus.vs == 1) & (r_misa.v == 1);
            s_vlenb_en  = (r_mstatus.vs == 1) & (r_misa.v == 1);
#endif
            s_cycle_en  = 1;
            s_time_en   = 1;
            s_instret_en = 1;
            s_hpmcounter_6_3_en  = 0b1111;
            s_hpmcounter_31_7_en = 0x1FFFFFF;
        } 
        else {
            switch (s_prv_mode)
            {
                case OP_MODE_U:
                    s_fflags_en = (r_mstatus.fs == 1);
                    s_frm_en    = (r_mstatus.fs == 1);
                    s_fcsr_en   = (r_mstatus.fs == 1);
#if (OPTION_XLEN == 64)
                    s_vstart_en = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vxsat_en  = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vxrm_en   = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vcsr_en   = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vl_en     = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vtype_en  = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vlenb_en  = (r_mstatus.vs == 1) & (r_misa.v == 1);
#endif
                    //U-mode counters are enabled by both r_scounteren and r_mcounteren
                    s_cycle_en  = (r_scounteren.cy == 1) & (r_mcounteren.cy == 1);
                    s_time_en   = (r_scounteren.tm == 1) & (r_mcounteren.tm == 1);
                    s_instret_en = (r_scounteren.ir == 1) & (r_mcounteren.ir == 1);
                    s_hpmcounter_6_3_en  = r_scounteren.hpm6_3[3..0] & r_mcounteren.hpm6_3[3..0];
                    s_hpmcounter_31_7_en = 0;
                    break;
                case OP_MODE_S:
                    s_fflags_en = (r_mstatus.fs == 1);
                    s_frm_en    = (r_mstatus.fs == 1);
                    s_fcsr_en   = (r_mstatus.fs == 1);
#if (OPTION_XLEN == 64)
                    s_vstart_en = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vxsat_en  = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vxrm_en   = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vcsr_en   = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vl_en     = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vtype_en  = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vlenb_en  = (r_mstatus.vs == 1) & (r_misa.v == 1);
#endif
                    s_cycle_en  = (r_mcounteren.cy == 1);
                    s_time_en   = (r_mcounteren.tm == 1);
                    s_instret_en = (r_mcounteren.ir == 1);
                    s_hpmcounter_6_3_en  = r_mcounteren.hpm6_3[3..0];
                    s_hpmcounter_31_7_en = 0;
                    break;
                case OP_MODE_M:
                    s_fflags_en = (r_mstatus.fs == 1);
                    s_frm_en    = (r_mstatus.fs == 1);
                    s_fcsr_en   = (r_mstatus.fs == 1);
#if (OPTION_XLEN == 64)
                    s_vstart_en = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vxsat_en  = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vxrm_en   = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vcsr_en   = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vl_en     = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vtype_en  = (r_mstatus.vs == 1) & (r_misa.v == 1);
                    s_vlenb_en  = (r_mstatus.vs == 1) & (r_misa.v == 1);
#endif
                    s_cycle_en  = 1;
                    s_time_en   = 1;
                    s_instret_en = 1;
                    s_hpmcounter_6_3_en  = 0b1111;
                    s_hpmcounter_31_7_en = 0x1FFFFFF;
                    break;
                default:
                    s_fflags_en = 0;
                    s_frm_en    = 0;
                    s_fcsr_en   = 0;
#if (OPTION_XLEN == 64)
                    s_vstart_en = 0;
                    s_vxsat_en  = 0;
                    s_vxrm_en   = 0;
                    s_vcsr_en   = 0;
                    s_vl_en     = 0;
                    s_vtype_en  = 0;
                    s_vlenb_en  = 0;
#endif
                    s_cycle_en  = 0;
                    s_time_en   = 0;
                    s_instret_en = 0;
                    s_hpmcounter_6_3_en  = 0;
                    s_hpmcounter_31_7_en = 0;
                    break;
            }
        }


#ifdef PMP_ENABLE
        s_pmpcfg0_en  = 1;
        s_pmpcfg2_en  = 1;
        s_pmpcfg4_en  = 1;
        s_pmpcfg6_en  = 1;
        s_pmpaddr_15_0_en  = 1;
//        s_pmpaddr_63_16_en = 1;
    #if (OPTION_XLEN == 32)
        s_pmpcfg1_en  = 1;
        s_pmpcfg3_en  = 1;
        s_pmpcfg5_en  = 1;
        s_pmpcfg7_en  = 1;
    #endif
#else
        s_pmpcfg0_en  = 0;
        s_pmpcfg2_en  = 0;
        s_pmpcfg4_en  = 0;
        s_pmpcfg6_en  = 0;
        s_pmpaddr_15_0_en  = 0;
//        s_pmpaddr_63_16_en = 0;
    #if (OPTION_XLEN == 32)
        s_pmpcfg1_en  = 0;
        s_pmpcfg3_en  = 0;
        s_pmpcfg5_en  = 0;
        s_pmpcfg7_en  = 0;
    #endif
#endif


        //flag csr exception
        csr_excep_ind_ex3 = r_csr_excep_ind_ex3;
        csr_excep_arg_ex3 = r_csr_excep_arg_ex3;
    }

    // ----------------------------------------------------------------------------------------
    // Private Function - Debug-only
    // ----------------------------------------------------------------------------------------
    always uint1 check_dbg_only_err(csr_addr_t raddr)
    {
        uint1 s_dbg_only_err;

        if (~s_dbg_mode) {
            switch (raddr) {
                case CSR_DCSR:      s_dbg_only_err = 1; break;
                case CSR_DPC:       s_dbg_only_err = 1; break;
                case CSR_DSCRATCH0: s_dbg_only_err = 1; break;
                case CSR_DSCRATCH1: s_dbg_only_err = 1; break;
                default: s_dbg_only_err = 0; break;
            }    
        }
        else {
            s_dbg_only_err = 0;
        }

        return s_dbg_only_err;
    }

// ********************************************************************************************
//  Function APIs (Invalid, Refetch, Active write, PLC instructions)
// ********************************************************************************************
    // ----------------------------------------------------------------------------------------
    // Public Function - CSR invalid tlb output (to PLC)
    // ----------------------------------------------------------------------------------------
    public always void get_csr_inval_tlb(uint1& csr_inval_tlb_ex3)
    {
        csr_inval_tlb_ex3 = s_write_ex3 & (s_waddr_ex3 == CSR_SATP);
    }

    // ----------------------------------------------------------------------------------------
    // Public Function - CSR refetch next PC output and flush pipeline (to PLC)
    // ----------------------------------------------------------------------------------------
    public always void get_csr_refetch_flush(uint1& csr_refetch_ex3)
    {
        bool fetch_next;

        fetch_next = s_write_ex3 &
                     (  (s_waddr_ex3 == CSR_SSTATUS) |
                        (s_waddr_ex3 == CSR_SATP) |
                        (s_waddr_ex3 == CSR_MSTATUS) |
                        (s_waddr_ex3 == CSR_MCOUNTINHIBIT) |
                        (s_waddr_ex3 == CSR_MCFGCTRL) |
                        (s_waddr_ex3 == CSR_MDCACHECTRL) |
                        (s_waddr_ex3 == CSR_MICACHECTRL) |
#if (OPTION_XLEN == 64)
                        (s_waddr_ex3 == CSR_ML2CACHECTRL) |
#endif
                        (s_waddr_ex3 == CSR_SBPREDCTRL)
                     );

        csr_refetch_ex3 = fetch_next & ~s_ex3_flush;
    }

    // ----------------------------------------------------------------------------------------
    // Public Function - Active CSR write (to PLC)
    // ----------------------------------------------------------------------------------------
    public always void get_act_csr_wr(uint1& csr_active_write)
    {
       r_write_wb = s_write_ex3;
       
       csr_active_write =   r_instr_csrrw_ex2 | r_instr_csrwo_ex2 | r_instr_csrrs_ex2 | r_instr_csrrc_ex2 | //EX2 write
                            r_instr_csrrw_ex3 | r_instr_csrwo_ex3 | r_instr_csrrs_ex3 | r_instr_csrrc_ex3 | //EX3 write
                            r_write_wb;
    } 

    // ----------------------------------------------------------------------------------------
    // Public Function - Output PLC instructions (to PLC)
    // ----------------------------------------------------------------------------------------
    public always void get_csr_plc_instr(
                    //Output
                    struct csr_plc_ctrl_t &   plc_instr_ex2
                    )
    {
        plc_instr_ex2.ebreak = r_instr_ebreak_ex2;
        plc_instr_ex2.ecall  = r_instr_ecall_ex2;
        plc_instr_ex2.dret   = r_instr_dret_ex2;
        plc_instr_ex2.mret   = r_instr_mret_ex2;
        plc_instr_ex2.sret   = r_instr_sret_ex2;
        plc_instr_ex2.wfi    = r_instr_wfi_ex2;
    }



// ********************************************************************************************
//  Shadow Registers
// ********************************************************************************************
    // ----------------------------------------------------------------------------------------
    // Private Functions - SW Read/Write shadow registers
    // ----------------------------------------------------------------------------------------
    always void check_shdw_raddr(csr_addr_t raddr) //13-bit for CHERI support
    {
        s_shdw_read_err = 0;  //read disabled reg
        s_shdw_rd_time = 0;
#if (OPTION_XLEN == 32)
        s_shdw_rd_timeh = 0;
#endif
        s_shdw_read_only = 0; //Read-only reg
        s_shdw_dbg_reg = 0;

        switch (raddr) {
            case CSR_FFLAGS:        s_shdw_raddr = CSR_FCSR;            s_shdw_read_err = ~s_fflags_en;                break;
            case CSR_FRM:           s_shdw_raddr = CSR_FCSR;            s_shdw_read_err = ~s_frm_en;                   break;
#if (OPTION_XLEN == 64)
            case CSR_VXSAT:         s_shdw_raddr = CSR_VCSR;            s_shdw_read_err = ~s_vxsat_en;                 break;
            case CSR_VXRM:          s_shdw_raddr = CSR_VCSR;            s_shdw_read_err = ~s_vxrm_en;                  break;
#endif
            case CSR_SIE:           s_shdw_raddr = CSR_MIE;                                                            break;
            case CSR_SIP:           s_shdw_raddr = CSR_MIP;                                                            break;
            case CSR_SSTATUS:       s_shdw_raddr = CSR_MSTATUS;                                                        break;
            case CSR_CYCLE:         s_shdw_raddr = CSR_MCYCLE;          s_shdw_read_err = ~s_cycle_en;                 
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_TIME:                                              s_shdw_read_err = ~s_time_en;                  
                                    s_shdw_rd_time = 1;                 s_shdw_read_only = 1;                          break;
            case CSR_INSTRET:       s_shdw_raddr = CSR_MINSTRET;        s_shdw_read_err = ~s_instret_en;               
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER3:   s_shdw_raddr = CSR_MHPMCOUNTER3;    s_shdw_read_err = ~s_hpmcounter_6_3_en[0];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER4:   s_shdw_raddr = CSR_MHPMCOUNTER4;    s_shdw_read_err = ~s_hpmcounter_6_3_en[1];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER5:   s_shdw_raddr = CSR_MHPMCOUNTER5;    s_shdw_read_err = ~s_hpmcounter_6_3_en[2]; 
                                                                        s_shdw_read_only = 1;                          break; 
            case CSR_HPMCOUNTER6:   s_shdw_raddr = CSR_MHPMCOUNTER6;    s_shdw_read_err = ~s_hpmcounter_6_3_en[3];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER7:   s_shdw_raddr = CSR_MHPMCOUNTER7;    s_shdw_read_err = ~s_hpmcounter_31_7_en[0];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER8:   s_shdw_raddr = CSR_MHPMCOUNTER8;    s_shdw_read_err = ~s_hpmcounter_31_7_en[1];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER9:   s_shdw_raddr = CSR_MHPMCOUNTER9;    s_shdw_read_err = ~s_hpmcounter_31_7_en[2];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER10:  s_shdw_raddr = CSR_MHPMCOUNTER10;   s_shdw_read_err = ~s_hpmcounter_31_7_en[3];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER11:  s_shdw_raddr = CSR_MHPMCOUNTER11;   s_shdw_read_err = ~s_hpmcounter_31_7_en[4];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER12:  s_shdw_raddr = CSR_MHPMCOUNTER12;   s_shdw_read_err = ~s_hpmcounter_31_7_en[5];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER13:  s_shdw_raddr = CSR_MHPMCOUNTER13;   s_shdw_read_err = ~s_hpmcounter_31_7_en[6];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER14:  s_shdw_raddr = CSR_MHPMCOUNTER14;   s_shdw_read_err = ~s_hpmcounter_31_7_en[7];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER15:  s_shdw_raddr = CSR_MHPMCOUNTER15;   s_shdw_read_err = ~s_hpmcounter_31_7_en[8];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER16:  s_shdw_raddr = CSR_MHPMCOUNTER16;   s_shdw_read_err = ~s_hpmcounter_31_7_en[9];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER17:  s_shdw_raddr = CSR_MHPMCOUNTER17;   s_shdw_read_err = ~s_hpmcounter_31_7_en[10];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER18:  s_shdw_raddr = CSR_MHPMCOUNTER18;   s_shdw_read_err = ~s_hpmcounter_31_7_en[11];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER19:  s_shdw_raddr = CSR_MHPMCOUNTER19;   s_shdw_read_err = ~s_hpmcounter_31_7_en[12];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER20:  s_shdw_raddr = CSR_MHPMCOUNTER20;   s_shdw_read_err = ~s_hpmcounter_31_7_en[13];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER21:  s_shdw_raddr = CSR_MHPMCOUNTER21;   s_shdw_read_err = ~s_hpmcounter_31_7_en[14];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER22:  s_shdw_raddr = CSR_MHPMCOUNTER22;   s_shdw_read_err = ~s_hpmcounter_31_7_en[15];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER23:  s_shdw_raddr = CSR_MHPMCOUNTER23;   s_shdw_read_err = ~s_hpmcounter_31_7_en[16];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER24:  s_shdw_raddr = CSR_MHPMCOUNTER24;   s_shdw_read_err = ~s_hpmcounter_31_7_en[17];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER25:  s_shdw_raddr = CSR_MHPMCOUNTER25;   s_shdw_read_err = ~s_hpmcounter_31_7_en[18];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER26:  s_shdw_raddr = CSR_MHPMCOUNTER26;   s_shdw_read_err = ~s_hpmcounter_31_7_en[19];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER27:  s_shdw_raddr = CSR_MHPMCOUNTER27;   s_shdw_read_err = ~s_hpmcounter_31_7_en[20];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER28:  s_shdw_raddr = CSR_MHPMCOUNTER28;   s_shdw_read_err = ~s_hpmcounter_31_7_en[21];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER29:  s_shdw_raddr = CSR_MHPMCOUNTER29;   s_shdw_read_err = ~s_hpmcounter_31_7_en[22];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER30:  s_shdw_raddr = CSR_MHPMCOUNTER30;   s_shdw_read_err = ~s_hpmcounter_31_7_en[23];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER31:  s_shdw_raddr = CSR_MHPMCOUNTER31;   s_shdw_read_err = ~s_hpmcounter_31_7_en[24];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_DDATA0:        s_shdw_dbg_reg = 1;                                                                break;
#if (OPTION_XLEN == 32)
            case CSR_CYCLEH:        s_shdw_raddr = CSR_MCYCLEH;         s_shdw_read_err = ~s_cycle_en;                 
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_TIMEH:                                             s_shdw_read_err = ~s_time_en;                  
                                    s_shdw_rd_timeh = 1;                s_shdw_read_only = 1;                          break; 
            case CSR_INSTRETH:      s_shdw_raddr = CSR_MINSTRETH;       s_shdw_read_err = ~s_instret_en;               
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER3H:  s_shdw_raddr = CSR_MHPMCOUNTER3H;   s_shdw_read_err = ~s_hpmcounter_6_3_en[0];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER4H:  s_shdw_raddr = CSR_MHPMCOUNTER4H;   s_shdw_read_err = ~s_hpmcounter_6_3_en[1];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER5H:  s_shdw_raddr = CSR_MHPMCOUNTER5H;   s_shdw_read_err = ~s_hpmcounter_6_3_en[2];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER6H:  s_shdw_raddr = CSR_MHPMCOUNTER6H;   s_shdw_read_err = ~s_hpmcounter_6_3_en[3];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER7H:  s_shdw_raddr = CSR_MHPMCOUNTER7H;   s_shdw_read_err = ~s_hpmcounter_31_7_en[0];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER8H:  s_shdw_raddr = CSR_MHPMCOUNTER8H;   s_shdw_read_err = ~s_hpmcounter_31_7_en[1];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER9H:  s_shdw_raddr = CSR_MHPMCOUNTER9H;   s_shdw_read_err = ~s_hpmcounter_31_7_en[2];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER10H: s_shdw_raddr = CSR_MHPMCOUNTER10H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[3];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER11H: s_shdw_raddr = CSR_MHPMCOUNTER11H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[4];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER12H: s_shdw_raddr = CSR_MHPMCOUNTER12H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[5];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER13H: s_shdw_raddr = CSR_MHPMCOUNTER13H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[6];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER14H: s_shdw_raddr = CSR_MHPMCOUNTER14H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[7];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER15H: s_shdw_raddr = CSR_MHPMCOUNTER15H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[8];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER16H: s_shdw_raddr = CSR_MHPMCOUNTER16H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[9];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER17H: s_shdw_raddr = CSR_MHPMCOUNTER17H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[10];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER18H: s_shdw_raddr = CSR_MHPMCOUNTER18H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[11];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER19H: s_shdw_raddr = CSR_MHPMCOUNTER19H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[12];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER20H: s_shdw_raddr = CSR_MHPMCOUNTER20H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[13];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER21H: s_shdw_raddr = CSR_MHPMCOUNTER21H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[14];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER22H: s_shdw_raddr = CSR_MHPMCOUNTER22H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[15];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER23H: s_shdw_raddr = CSR_MHPMCOUNTER23H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[16];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER24H: s_shdw_raddr = CSR_MHPMCOUNTER24H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[17];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER25H: s_shdw_raddr = CSR_MHPMCOUNTER25H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[18];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER26H: s_shdw_raddr = CSR_MHPMCOUNTER26H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[19];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER27H: s_shdw_raddr = CSR_MHPMCOUNTER27H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[20];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER28H: s_shdw_raddr = CSR_MHPMCOUNTER28H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[21];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER29H: s_shdw_raddr = CSR_MHPMCOUNTER29H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[22];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER30H: s_shdw_raddr = CSR_MHPMCOUNTER30H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[23];
                                                                        s_shdw_read_only = 1;                          break;
            case CSR_HPMCOUNTER31H: s_shdw_raddr = CSR_MHPMCOUNTER31H;  s_shdw_read_err = ~s_hpmcounter_31_7_en[24];
                                                                        s_shdw_read_only = 1;                          break;
#endif
#ifdef OPTION_HAS_CHERI
            //DDC, STDC, MTDC are implemented outside CSR_Bank, therefore are not shadowing CSRs
            case CSR_STCC_ADDR:         s_shdw_raddr = CSR_STVEC;       break;
            case CSR_SSCRATCHC_ADDR:    s_shdw_raddr = CSR_SSCRATCH;    break;
            case CSR_SEPCC_ADDR:        s_shdw_raddr = CSR_SEPC;        break;
            case CSR_DSCRATCH0C_ADDR:   s_shdw_raddr = CSR_DSCRATCH0;   break;
            case CSR_DSCRATCH1C_ADDR:   s_shdw_raddr = CSR_DSCRATCH1;   break;
            case CSR_DPCC_ADDR:         s_shdw_raddr = CSR_DPC;         break;
            case CSR_MTCC_ADDR:         s_shdw_raddr = CSR_MTVEC;       break;
            case CSR_MSCRATCHC_ADDR:    s_shdw_raddr = CSR_MSCRATCH;    break;
            case CSR_MEPCC_ADDR:        s_shdw_raddr = CSR_MEPC;        break;
#endif /*OPTION_HAS_CHERI*/
            default:                    s_shdw_raddr = raddr;
                                        s_shdw_read_err = 0; //unsupported address is checked in csr_bank                 
                                        s_shdw_rd_time = 0;
#if (OPTION_XLEN == 32)
                                        s_shdw_rd_timeh = 0;
#endif
                                        s_shdw_read_only = 0;
                                        s_shdw_dbg_reg = 0;
                                        break;
        }

    }

    private xlen_t shdw_rdata_shft( //shift rdata due to different bit index presented in shadow and original registers
        //input
        csr_addr_t      raddr,
        xlen_t          rdata
        )
    {
        xlen_t          rdata_sh;
        switch (raddr) {
            case CSR_FFLAGS: rdata_sh = (uint_<{XLEN-5}>)0 :: rdata[4..0]; break;
            case CSR_FRM:    rdata_sh = (uint_<{XLEN-3}>)0 :: rdata[7..5]; break; //FRRM instruction
#if (OPTION_XLEN == 64)
            case CSR_VXSAT:  rdata_sh = (uint_<{XLEN-3}>)0 :: rdata[0];    break;
            case CSR_VXRM:   rdata_sh = (uint_<{XLEN-3}>)0 :: rdata[3..2]; break;
#endif
            case CSR_SIE:    rdata_sh = (uint_<{XLEN-10}>)0 :: r_mie.seie :: (uint3)0 :: r_mie.stie :: (uint3)0 :: r_mie.ssie :: (uint1)0; break;
            case CSR_SIP:    rdata_sh = (uint_<{XLEN-10}>)0 :: r_mip.seip :: (uint3)0 :: r_mip.stip :: (uint3)0 :: r_mip.ssip :: (uint1)0; break;
#if (OPTION_XLEN == 64)
            case CSR_SSTATUS: rdata_sh = r_mstatus.sd  :: (uint29)0 :: r_mstatus.uxl :: (uint12)0 :: //bit[63:20]
#else
            case CSR_SSTATUS: rdata_sh = r_mstatus.sd  :: (uint11)0 ::                                          //bit[31:20]
#endif
                                         r_mstatus.mxr :: r_mstatus.sum  :: (uint1)0 ::              //bit[19:17]
                                         r_mstatus.xs  :: r_mstatus.fs   :: (uint2)0 ::              //bit[16:11]
                                         r_mstatus.vs  :: r_mstatus.spp  :: (uint1)0 ::              //bit[10:7]
                                         r_mstatus.ube :: r_mstatus.spie :: (uint3)0 ::              //bit[6:2]
                                         r_mstatus.sie :: (uint1)0; break;                                      //bit[1:0]

            default:         rdata_sh = rdata; break;
        }
       return rdata_sh;
    }

    private xlen_t shdw_wdata_shft( //csr write - only update part of the register.
        csr_addr_t      waddr, 
        xlen_t          wdata)
    {
        xlen_t          wdata_sh;
        switch (waddr) {
            case CSR_FFLAGS: wdata_sh = (uint_<{XLEN-8}>)0 :: r_fcsr.frm :: wdata[4..0];     break; //fcsr is 32-bit wide
            case CSR_FRM:    wdata_sh = (uint_<{XLEN-8}>)0 :: wdata[2..0] :: r_fcsr.fflags;  break;
#if (OPTION_XLEN == 64)
            case CSR_VXSAT:  wdata_sh = (uint_<{XLEN-3}>)0 :: r_vcsr.vxrm :: wdata[0];       break; //vcsr is 3-bit wide
            case CSR_VXRM:   wdata_sh = (uint_<{XLEN-3}>)0 :: wdata[1..0] :: r_vcsr.vxsat;   break;
#endif
            case CSR_SIE:    wdata_sh = (uint_<{XLEN-12}>)0  :: (uint1)0 :: r_mie.meie ::           //no change on meie
                                        (uint1)0 :: wdata[9] :: (uint1)0 :: r_mie.mtie ::           //no change on mtie
                                        (uint1)0 :: wdata[5] :: (uint1)0 :: r_mie.msie ::           //no change on msie
                                        (uint1)0 :: wdata[1] :: (uint1)0;                               break;
            case CSR_SIP:    wdata_sh = (uint_<{XLEN-12}>)0  :: (uint1)0 :: r_mip.meip ::           //no change on meip 
                                        //(uint1)0 :: wdata[9] :: (uint1)0 :: r_mip.mtip ::           //no change on mtip
                                        //(uint1)0 :: wdata[5] :: (uint1)0 :: r_mip.msip ::           //no change on msip
                                        (uint1)0 :: r_mip.seip :: (uint1)0 :: r_mip.mtip :://no change on mtip, [9]-seip is RO 
                                        (uint1)0 :: r_mip.stip :: (uint1)0 :: r_mip.msip :://no change on msip, [5]-stip is RO
                                        (uint1)0 :: wdata[1] :: (uint1)0;                               break;
#if (OPTION_XLEN == 64)
            case CSR_SSTATUS: wdata_sh = wdata[63] :: (uint25)0 :: r_mstatus.mbe ::                 //Update 63-SD
                                         //r_mstatus.sbe :: wdata[35..32] :: (uint9)0  ::             //Update [35:34]-SXL, [33:32]-UXL
                                         r_mstatus.sbe :: 0b1010 :: (uint9)0  ::                    //Constant values: [35:34]-SXL=2, [33:32]-UXL=2
#else
            case CSR_SSTATUS: wdata_sh = wdata[31] :: (uint8)0 ::                                              //Update 31-SD
#endif
                                         r_mstatus.tsr :: r_mstatus.tw  :: r_mstatus.tvm :: //[22:20] no change
                                         wdata[19..18] :: r_mstatus.mprv ::                         //update 19-MXR, 18-SUM
                                         wdata[16..13] :: r_mstatus.mpp :: wdata[10..8]  ::         //update [16:15]-XS, [14:13]-FS, [10:9]-VS, [8]-SPP
                                         //r_mstatus.mpie :: wdata[6..5] :: (uint1)0 ::               //update [6]-UBE, [5]-SPIE
                                         r_mstatus.mpie :: (uint1)0 :: wdata[5] :: (uint1)0 ::      //Constant [6]-UBE=0, update [5]-SPIE
                                         r_mstatus.mie :: (uint1)0 :: wdata[1] :: (uint1)0;  break; //update 1-SIE 
                                         
            default:          wdata_sh = wdata;                                                         break;
        }
       return wdata_sh;
    }

// ********************************************************************************************
//  WARL support
// ********************************************************************************************   
    // --------------------------------------------------
    // Private Function - SW write to WARL registers:
    // ---- convert illegal data to pre-defined value
    // --------------------------------------------------

    private xlen_t warl_wdata_conv(
        uint12          waddr, //not related to CHERI SCR
        xlen_t          wdata)
    {
        xlen_t          wdata_conv;
        uint1           satp_mode_conv64;
        uint4           tdata1_type_conv;
        uint4           tdata1_action_conv;
        uint6           xcause_reserved_val;

#if (OPTION_XLEN == 64) 
        //satp.mode
        switch (wdata[63..60]) {
            case 0b1000: satp_mode_conv64 = wdata[63..60]; break; //SV39
            case 0b1001: satp_mode_conv64 = wdata[63..60]; break; //SV48
            case 0b1010: satp_mode_conv64 = wdata[63..60]; break; //SV57
            case 0b1011: satp_mode_conv64 = wdata[63..60]; break; //SV64
            default: satp_mode_conv64 = 0b0000; break; //illegal: convert to Bare mode
        }
#endif

        //tdata1.type
#if (OPTION_XLEN == 64)
        switch(wdata[63..60]) {
            case 0b0110: tdata1_type_conv = wdata[63..60]; break; //6
            default: tdata1_type_conv = 0b0000; break; //illegal: convert to 0
        }
#else
        switch(wdata[31..28]) {
            case 0b0110: tdata1_type_conv = wdata[31..28]; break; //6
            default: tdata1_type_conv = 0b0000; break; //illegal: convert to 0
        }
#endif

        //tdata1.action
        switch(wdata[15..12]) {
            case 0b0001: tdata1_action_conv = wdata[15..12]; break; //1
            case 0b0010: tdata1_action_conv = wdata[15..12]; break; //2
            case 0b0011: tdata1_action_conv = wdata[15..12]; break; //3
            case 0b0100: tdata1_action_conv = wdata[15..12]; break; //4
            default: tdata1_action_conv = 0b0000; break; //illegal: convert to 0
        }

        //xcause.expt reserved values: 10, 14, 16-23, 32-47, >=64
        //>=64 is guarded by the CSR spreadsheet, defining expt to be 6 bits and other bits set to wpri
        xcause_reserved_val =   (wdata[5..0] == 0b001010) |         //10
                                (wdata[5..0] == 0b001111) |         //14
                                (~wdata[5] & wdata[4] & wdata[3]) | //16-23
                                (wdata[5] & ~wdata[4]);             //32-47  

        switch (waddr) {
#if (OPTION_XLEN == 64) 
            case CSR_MSTATUS: wdata_conv = wdata[63] :: (uint25)0 :: wdata[37..36] ::   //bit[62..38] reserved
                                           (uint2)2 :: (uint2)2 :: (uint9)0 ::          //bit[35:34]=SXL=2, bit[33:32]=UXL=2, bit[31:23] reserved
#else
            case CSR_MSTATUS: wdata_conv = wdata[31] :: wdata[30..23] ::                //bit[30..23] reserved
#endif
                                           wdata[22..5] :: (uint1)0 :: wdata[3] ::      //bit[4] reserved
                                           (uint1)0 :: wdata[1] :: (uint1)0; break;     //bit[2] reserved, bit[0] reserved
                              
                                        
#if (OPTION_XLEN == 32)             
            case CSR_MSTATUSH: wdata_conv = (uint32)0; break; //bit[5]=MBE=0, bit[4]=SBE=0
#endif 
            case CSR_MIP:    wdata_conv = (uint_<{XLEN-12}>)0 :: r_mip.meip :: (uint1)0 :: r_mip.seip :: //MEIP: RO, no SW update
                                                      (uint1)0 :: r_mip.mtip :: (uint1)0 :: r_mip.stip :: //MTIP: RO, no SW update
                                                      (uint1)0 :: r_mip.msip :: (uint1)0 :: r_mip.ssip :: //MSIP: RO, no SW update
                                                      (uint1)0; break;
#if (OPTION_XLEN == 64)             
            case CSR_SATP:    wdata_conv = satp_mode_conv64 :: r_satp.asid :: r_satp.ppn; break;
#endif
            case CSR_STVAL:  wdata_conv = wdata; break; //TODO: convert illegal virtual address to 0
            case CSR_MTVAL:  wdata_conv = wdata; break; //TODO: convert illegal virtual address to 0
            case CSR_TDATA1: wdata_conv = tdata1_type_conv :: wdata[XLEN-5] :: (uint_<{XLEN-21}>)0 :: //bit[XLEN-6:16] always 0
                                          tdata1_action_conv :: (uint7)0 :: wdata[4..0];              //bit[11:5] always 0
                             break;
            case CSR_SCAUSE: wdata_conv = xcause_reserved_val ? (uint6)2: //convert unsupported value to 2
                                                                (r_scause.intr :: (uint_<{XLEN-7}>)0 :: r_scause.expt);
                             break;
            case CSR_MCAUSE: wdata_conv = xcause_reserved_val ? (uint6)2: //convert unsupported value to 2
                                                                (r_mcause.intr :: (uint_<{XLEN-7}>)0 :: r_mcause.expt);
                             break;
            default: wdata_conv = wdata; break;
        }
        return wdata_conv;
    }


    // ----------------------------------------------------------------------------------------
    // Public Function - HW Direct Read
    // ----------------------------------------------------------------------------------------
    //To FPU
    public always void get_csr_frm(uint3& csr_frm) { csr_frm = r_fcsr.frm; }

    /**
     * CSR custom configuration (to DCI)
     */
    public always void get_dci_config(  bool &dis_late_alu, 
                                        bool &dis_alu_agu_dual_issue,
                                        bool &dis_mv_dual_issue,
                                        bool &dis_alu_logic_dual_issue,
                                        bool &dis_slot1,
                                        bool &dis_all_dual_issue,
                                        bool &dis_spec_state_issue,
                                        bool &dis_br_pred)
    {
        dis_late_alu                = r_mcfgctrl.dis_late_alu;
        dis_all_dual_issue          = r_mcfgctrl.dis_all_dual_issue;
        dis_alu_agu_dual_issue      = r_mcfgctrl.dis_alu_agu_dual_issue;
        dis_mv_dual_issue           = r_mcfgctrl.dis_mv_dual_issue;
        dis_alu_logic_dual_issue    = r_mcfgctrl.dis_alu_logic_dual_issue;
        dis_slot1                   = r_mcfgctrl.dis_slot1;
        dis_spec_state_issue        = r_mcfgctrl.dis_spec_state_issue;
        dis_br_pred                 = r_mcfgctrl.dis_br_pred;
    }

    /**
     * CSR custom configuration (To IFU/DCU)
     */
    public always void get_csr_mdcachectrl(uint4 &manage_dcache) { manage_dcache = r_mdcachectrl.manage_dcache; }
    public always void get_csr_micachectrl(uint3 &manage_icache) { manage_icache = r_micachectrl.manage_icache; }
#if (OPTION_XLEN == 64)
    #ifdef OPTION_HAS_L2CACHE
    public always void get_csr_ml2cachectrl(uint4 &manage_l2cache) { 
        manage_l2cache = r_ml2cachectrl.manage_l2cache; 
    }
    #endif
#endif    
    public always void get_csr_sbpredctrl(uint1 &flush_bpred) { flush_bpred = r_sbpredctrl.flush_bpred; }
    
    //To MMU
    //PMP configuration register format
    // | 7 | 6..5 | 4..3 | 2 | 1 | 0 |
    // | L |  0   |  A   | X | W | R |
    public always void get_mmu_csr_intf(struct mmu_csr_t &mmu_csr_registers)
    {
        uint_<{(PA_4K_AL+1)}> pmp_addr_array[OPTION_PMP_SIZE];
        
        if (s_dbg_mode) {
            mmu_csr_registers.vm_trans_en = ~(|r_satp.mode) &  //SATP.MODE != Bare
                                            r_dcsr.mprven &    //DCSR.MPRVEN == 1 
                                            r_mstatus.mprv &   //MSTATUS.MPRV == 1
                                            ~r_mstatus.mpp[1]; //MSTATUS.MPP == 00 (U) or MSTATUS.MPP == 01 (S)
                             
        } 
        else {
            switch (s_prv_mode) {
                case OP_MODE_U: mmu_csr_registers.vm_trans_en = ~(|r_satp.mode); //SATP.MODE != Bare
                                break;
                case OP_MODE_S: mmu_csr_registers.vm_trans_en = ~(|r_satp.mode); //SATP.MODE != Bare
                                break;
                case OP_MODE_M: mmu_csr_registers.vm_trans_en = ~(|r_satp.mode) &  //SATP.MODE != Bare
                                                                r_mstatus.mprv &   //MSTATUS.MPRV == 1
                                                                ~r_mstatus.mpp[1]; //MSTATUS.MPP == 00 (U) or MSTATUS.MPP == 01 (S)
                                break;
                default:        mmu_csr_registers.vm_trans_en = ~(|r_satp.mode); //reserved, never occurs
                                break;
            }
        }

        
        //mcfgctrl
        mmu_csr_registers.dis_large_tlb_page = r_mcfgctrl.dis_large_tlb_page;
        //satp
        mmu_csr_registers.satp_asid = r_satp.asid;
        mmu_csr_registers.satp_ppn  = r_satp.ppn[PA_4K_AL-1..0];
        //pmpcfg //TODO: change to struct type & remove pmpcfg4-7
#if (OPTION_XLEN == 64)
        mmu_csr_registers.pmp_cfg = (r_pmpcfg2[7] :: (uint2)0 :: r_pmpcfg2[4..0]) :: //bit[6:5] reserved
                                    (r_pmpcfg0[7] :: (uint2)0 :: r_pmpcfg0[4..0]);   //bit[6:5] reserved
#else
        mmu_csr_registers.pmp_cfg = (r_pmpcfg3[7] :: (uint2)0 :: r_pmpcfg3[4..0]) :: 
                                    (r_pmpcfg2[7] :: (uint2)0 :: r_pmpcfg2[4..0]) :: 
                                    (r_pmpcfg1[7] :: (uint2)0 :: r_pmpcfg1[4..0]) :: 
                                    (r_pmpcfg0[7] :: (uint2)0 :: r_pmpcfg0[4..0]);
#endif
        //pmpaddr //TODO: change to struct type
        $$for(i=0; i<OPTION_PMP_SIZE;i++)
            pmp_addr_array[$$(i)] = r_pmpaddr$$(i)[PA_4K_AL..0];
        $$endfor()
        mmu_csr_registers.pmp_addr = (bit uint_<{(PA_4K_AL+1)*OPTION_PMP_SIZE}>)pmp_addr_array;

    }


    //To DCI
#if (OPTION_XLEN == 64)
    #ifdef OPTION_EXTENSION_V
    public always void get_csr_vxrm(uint2& csr_vxrm) { 
        csr_vxrm = r_vcsr.vxrm; 
    }
    public always void get_csr_vtype(uint_<{SXLEN}>& csr_vtype)
    {
        csr_vtype = r_vtype.vill :: (uint_<{XLEN-9}>)0 :: r_vtype.vma :: r_vtype.vta :: r_vtype.vsew :: r_vtype.vlmul;
    }
    public always void get_csr_vstart(uint_<{SXLEN}>& csr_vstart) { csr_vstart = r_vstart; }
    #endif
#endif

    //To PLC
    public always void get_irq_ctrl(struct csr_irq_ctrl_t &state)
    {
        state.medeleg = (uint_<{MXLEN-16}>)0 :: r_medeleg.st_pg_fault :: (uint1)0 :: r_medeleg.ld_pg_fault :: 
                        r_medeleg.inst_pg_fault :: r_medeleg.ecall_m :: (uint1)0 :: r_medeleg.ecall_s :: r_medeleg.ecall_u :: 
                        r_medeleg.st_fault :: r_medeleg.st_mis_algn :: r_medeleg.ld_fault :: r_medeleg.ld_mis_algn :: 
                        r_medeleg.breakpoint :: r_medeleg.illegal_inst :: r_medeleg.pc_fault :: r_medeleg.pc_mis_algn;
        state.mideleg = (uint_<{MXLEN-12}>)0 :: r_mideleg.meid :: (uint1)0 :: r_mideleg.seid :: 
                        (uint1)0  :: r_mideleg.mtid :: (uint1)0 :: r_mideleg.stid :: 
                        (uint1)0  :: r_mideleg.msid :: (uint1)0 :: r_mideleg.ssid :: 
                        (uint1)0;
        state.mie     = (uint_<{MXLEN-12}>)0 :: r_mie.meie :: (uint1)0 :: r_mie.seie :: (uint1)0 :: r_mie.mtie :: (uint1)0 :: r_mie.stie :: (uint1)0 :: r_mie.msie :: (uint1)0 :: r_mie.ssie :: (uint1)0;
        state.mip     = (uint_<{MXLEN-12}>)0 :: r_mip.meip :: (uint1)0 :: r_mip.seip :: (uint1)0 :: r_mip.mtip :: (uint1)0 :: r_mip.stip :: (uint1)0 :: r_mip.msip :: (uint1)0 :: r_mip.ssip :: (uint1)0;
#if (OPTION_XLEN == 64)
        state.mstatus = r_mstatus.sd :: (uint25)0 :: r_mstatus.mbe :: r_mstatus.sbe :: r_mstatus.sxl :: r_mstatus.uxl :: (uint9)0 :: r_mstatus.tsr :: r_mstatus.tw :: r_mstatus.tvm :: r_mstatus.mxr :: r_mstatus.sum :: r_mstatus.mprv :: r_mstatus.xs :: r_mstatus.fs :: r_mstatus.mpp :: r_mstatus.vs :: r_mstatus.spp :: r_mstatus.mpie :: r_mstatus.ube :: r_mstatus.spie :: (uint1)0 :: r_mstatus.mie :: (uint1)0 :: r_mstatus.sie :: (uint1)0;
#else
        state.mstatus = r_mstatus.sd :: (uint8)0 :: r_mstatus.tsr :: r_mstatus.tw :: r_mstatus.tvm :: r_mstatus.mxr :: r_mstatus.sum :: r_mstatus.mprv :: r_mstatus.xs :: r_mstatus.fs :: r_mstatus.mpp :: r_mstatus.vs :: r_mstatus.spp :: r_mstatus.mpie :: r_mstatus.ube :: r_mstatus.spie :: (uint1)0 :: r_mstatus.mie :: (uint1)0 :: r_mstatus.sie :: (uint1)0;
        //TODO: add mstatush for L71
#endif
        state.mtvec   = r_mtvec.base :: (uint3)0 :: r_mtvec.mode;
        state.sie     = (uint_<{SXLEN-10}>)0 :: r_mie.seie :: (uint3)0 :: r_mie.stie :: (uint3)0 :: r_mie.ssie :: (uint1)0;
        state.sip     = (uint_<{SXLEN-10}>)0 :: r_mip.seip :: (uint3)0 :: r_mip.stip :: (uint3)0 :: r_mip.ssip :: (uint1)0;
        state.stvec   = r_stvec.base :: (uint3)0 :: r_stvec.mode;
        state.mepc    = r_mepc.epc :: (uint1)0;
        state.sepc    = r_sepc.epc :: (uint1)0;
    }
    
    public always void get_dbg_ctrl(uint32 &dcsr, xlen_t &dpc)
    {
        dcsr = r_dcsr.debugver :: (uint10)0 :: r_dcsr.ebreakvs :: r_dcsr.ebreakvu :: r_dcsr.ebreakm :: (uint1)0 :: r_dcsr.ebreaks :: r_dcsr.ebreaku :: r_dcsr.stepie :: r_dcsr.stopcount :: r_dcsr.stoptime :: r_dcsr.cause :: r_dcsr.v :: r_dcsr.mprven :: r_dcsr.nmip :: r_dcsr.step :: r_dcsr.prv;
        dpc  = r_dpc.dpc :: (uint1)0;
    }
    
    //To DPU
    public always uint12 get_hpmcounter_cfg3(void)
    {
        return r_mhpmevent3.evt[11..0];
    }
    public always uint12 get_hpmcounter_cfg4(void)
    {
        return r_mhpmevent4.evt[11..0];
    }
    public always uint12 get_hpmcounter_cfg5(void)
    {
        return r_mhpmevent5.evt[11..0];
    }
    public always uint12 get_hpmcounter_cfg6(void)
    {
        return r_mhpmevent6.evt[11..0];
    }

    //To DM
    public always void get_darg_writes(bool& valid, xlen_t& data)
    {
        valid = r_dbg_write_wb;
        data  = r_dbg_wdata_wb;
    }

// ********************************************************************************************
//  CHERI Support
// ********************************************************************************************
// ---------------------------- Start of CHERI --------------------------------------------
#ifdef OPTION_HAS_CHERI
    //CCU -> CSR Interface
    public always void set_ccu_excep (uint1 excep_ex3_i0)
    {
        s_ccu_excep_ex3_i0 = excep_ex3_i0;
    }

    //CSR --> CCU Interface
    public always void get_scrs_addr(
            xlen_t &ddc,
            xlen_t &stcc,
            xlen_t &stdc,
            xlen_t &sscratchc,
            xlen_t &sepcc,
            xlen_t &dscratch0c,
            xlen_t &dscratch1c,
            xlen_t &dpcc,
            xlen_t &mtcc,
            xlen_t &mtdc,
            xlen_t &mscratchc,
            xlen_t &mepcc)
    {
        ddc         = r_ddc;
        stcc        = r_stvec.base :: (uint3)0 :: r_stvec.mode;
        stdc        = r_stdc;
        sscratchc   = r_sscratch;
        sepcc       = r_sepc.epc :: (uint1)0;
        dscratch0c  = r_dscratch0;
        dscratch1c  = r_dscratch1;
        dpcc        = r_dpc.dpc :: (uint1)0;
        mtcc        = r_mtdc;
        mtdc        = r_mtvec.base :: (uint3)0 :: r_mtvec.mode;
        mscratchc   = r_mscratch;
        mepcc       = r_mepc.epc :: (uint1)0;
    }

    //SCR Read/Write (DDC/STDC/MTDC)
    automatic void scr_rd_access()
    {
        if (s_scr_read_ex2) //read SCR only if address bit[12] is set
        {
            s_scr_read_err_ex2 = 0;

            switch (s_scr_raddr_ex2[11..0]) //not s_raddr_ex2 which is translated for shadow CSRs
            {
                case CHERI_SCR_ADDR_PCC:        break; //PCC not implemented in CSR, but this address is supported
                case CHERI_SCR_ADDR_DDC:        s_scr_rdata_ex2 = r_ddc;                    break;
                case CHERI_SCR_ADDR_STCC:       s_scr_rdata_ex2 = r_stvec.base :: 
                                                                  (uint3)0 :: 
                                                                  r_stvec.mode;  break;
                case CHERI_SCR_ADDR_STDC:       s_scr_rdata_ex2 = r_stdc;                   break;
                case CHERI_SCR_ADDR_SSCRATCHC:  s_scr_rdata_ex2 = r_sscratch;    break;
                case CHERI_SCR_ADDR_SEPCC:      s_scr_rdata_ex2 = r_sepc.epc :: 
                                                                  (uint1)0;                 break;
                case CHERI_SCR_ADDR_DSCRATCH0:  s_scr_rdata_ex2 = r_dscratch0;   break;
                case CHERI_SCR_ADDR_DSCRATCH1:  s_scr_rdata_ex2 = r_dscratch1;   break;
                case CHERI_SCR_ADDR_DPCC:       s_scr_rdata_ex2 = r_dpc.dpc :: 
                                                                  (uint1)0;                 break;
                case CHERI_SCR_ADDR_MTCC:       s_scr_rdata_ex2 = r_mtvec.base :: 
                                                                  (uint3)0 :: 
                                                                  r_mtvec.mode;  break;
                case CHERI_SCR_ADDR_MTDC:       s_scr_rdata_ex2 = r_mtdc;                   break;
                case CHERI_SCR_ADDR_MSCRATCHC:  s_scr_rdata_ex2 = r_mscratch;    break;
                case CHERI_SCR_ADDR_MEPCC:      s_scr_rdata_ex2 = r_mepc.epc ::
                                                                  (uint1)0;                 break;
                default:                        s_scr_read_err_ex2 = 1; //access unsupported SCR addresses
                                                s_scr_rdata_ex2 = r_ddc;
                                                break;
            }
        }
    }

    automatic void scr_wr_access()
    {
        if (s_scr_xdc_write_ex3) //only write the following registers, others SCRs write to CSR_BANK
        {
            switch (s_waddr_ex3[11..0]) //same as CSR waddr, 12 bits
            {
                case CHERI_SCR_ADDR_DDC:   r_ddc   = s_wdata_ex3; break;
                case CHERI_SCR_ADDR_STDC:  r_stdc  = s_wdata_ex3; break;
                case CHERI_SCR_ADDR_MTDC:  r_mtdc  = s_wdata_ex3; break;
                default:                   //TODO: add assertion
                                           break;   
            }
        }
    }


#endif
// ----------------------------- End of CHERI ---------------------------------------------

  // FIXME Remove CLK and RST requirements in generated RTL
  register bool r_dummy;
  automatic void dummy_clock()
  {
      r_dummy = !r_dummy;
  }
  public bool get_test() { return r_dummy; }
};
